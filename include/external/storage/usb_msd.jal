-- Title: USB Mass Storage Device.
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q2
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Library for USB MSD (Mass Storage Device) with SD card,
--              hard disk, or jallib supported storage device.
--
-- Sources:
-- http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
-- http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
-- http://direction.scene-double.com/2008/07/08/usb-msd-bootloader-for-pic-microcontrollers.aspx
--
-- Notes:
--

include usb_defs -- USB Definitions

include storage_drivers

-- Select Write Speed. Extra speed may use more code space.
-- Only for devices that support it.
const byte USB_WRITE_SUPER_SPEED = 1  -- uses memory pointer for extra speed,
                                      -- data direct from devide to USB endpoint, no buffer array
const byte USB_WRITE_EXTRA_SPEED = 2  -- uses storage device extra speed routines,
                                      -- with 512 byte buffer array
const byte USB_WRITE_NORMAL_SPEED = 3 -- uses normal storage device routines
                                      -- with 512 byte buffer array
if (STORAGE_DEVICE == SD_CARD) | (STORAGE_DEVICE == PATA_HARD_DISK) then
   if defined(STORAGE_WRITE_EXTRA_SPEED) then
      if (STORAGE_WRITE_EXTRA_SPEED == TRUE) then
         if defined(storage_read_sector_with_callback) then
            const byte USB_WRITE_TRANSFER_SPEED = USB_WRITE_SUPER_SPEED
         else
            const byte USB_WRITE_TRANSFER_SPEED = USB_WRITE_EXTRA_SPEED
         end if
      else
         const byte USB_WRITE_TRANSFER_SPEED = USB_WRITE_NORMAL_SPEED
      end if
   else
         const byte USB_WRITE_TRANSFER_SPEED = USB_WRITE_NORMAL_SPEED
   end if
else
   const byte USB_WRITE_TRANSFER_SPEED = USB_WRITE_NORMAL_SPEED
end if

-- Select Read Speed. Extra speed may use more code space.
-- Only for devices that support it.
const byte USB_READ_SUPER_SPEED = 1  -- uses memory pointer for extra speed,
                                     -- data direct from devide to USB endpoint, no buffer array
const byte USB_READ_EXTRA_SPEED = 2  -- uses storage device extra speed routines,
                                     -- with 512 byte buffer array
const byte USB_READ_NORMAL_SPEED = 3 -- uses normal storage device routines
                                     -- with 512 byte buffer array.
if (STORAGE_DEVICE == SD_CARD) | (STORAGE_DEVICE == PATA_HARD_DISK) then
   if defined(STORAGE_READ_EXTRA_SPEED) then
      if (STORAGE_READ_EXTRA_SPEED == TRUE) then
         if defined(storage_read_sector_with_callback) then
            const byte USB_READ_TRANSFER_SPEED = USB_READ_SUPER_SPEED
         else
            const byte USB_READ_TRANSFER_SPEED = USB_READ_EXTRA_SPEED
         end if
      else
         const byte USB_READ_TRANSFER_SPEED = USB_READ_NORMAL_SPEED
      end if
   else
         const byte USB_READ_TRANSFER_SPEED = USB_READ_NORMAL_SPEED
   end if
else
   const byte USB_READ_TRANSFER_SPEED = USB_READ_NORMAL_SPEED
end if

-- variables
var dword usb_msd_sector_step_
var dword usb_msd_address
var byte usb_msd_address_[4] at usb_msd_address
var word usb_msd_step64_ = 0
var byte usb_msd_step_byte_ = 0

-- msd status
const USB_MSD_STATE_WAIT      = 0   -- waiting for a CBW from host
const USB_MSD_STATE_DATA_IN   = 1   -- data in state (time for device to send data to host)
const USB_MSD_STATE_DATA_OUT  = 2   -- data out state (time for device to receive from host)
var byte usb_msd_state  = USB_MSD_STATE_WAIT

-- size of the storage device
var dword usb_msd_num_of_blocks = storage_number_of_sectors
var byte usb_msd_num_of_blocks_[4] at usb_msd_num_of_blocks

-- UOWN bit
-- When SAE owns, we cannot use the endpoint. SAE is the usb module or  output interface.
-- When CPU owns, we can use the endpoint to write or send data.
-- We must give ownership back to SAE when we're done with it.
var volatile bit usb_msd_sae_owns_bit_in at usb_bd1in_stat : USB_BDSTATUS_UOWN	
var volatile bit usb_msd_sae_owns_bit_out at usb_bd1out_stat : USB_BDSTATUS_UOWN	
 	
-- prototypes. can't live without them :)
procedure usb_msd_process_data(byte in do_copy)
procedure usb_handle_isr()
procedure usb_send_csw()

-- CBW variables
const dword USB_MSD_CBW = 0x43425355      -- signature that helps identify data packet as a CBW
var dword usb_msd_cbw_signature = 0       -- variable to receive a CBW signature before checking
var byte usb_msd_cbw_signature_[4] at usb_msd_cbw_signature
var dword usb_msd_cbw_tag = 0             -- relat a SBW with a CSW at end of packet
var byte usb_msd_cbw_tag_[4] at usb_msd_cbw_tag
var dword usb_msd_cbw_data_transfer_length = 0 -- # of bytes of data that the host expects to transfer on the Bulk-In or Bulk-Out endpoint 1
var byte usb_msd_cbw_data_transfer_length_[4] at usb_msd_cbw_data_transfer_length
var volatile byte usb_msd_cbw_flags = 0   -- must be volatile otherwise compiler throws it away
var volatile byte usb_msd_cbw_cbw_lun = 0 -- must be volatile otherwise compiler throws it away
var volatile byte usb_msd_cbw_length = 0  -- must be volatile otherwise compiler throws it away
var byte*16 usb_msd_cbw_command = 0       -- command and parameters for a received CBW
var byte usb_msd_cbw_command_[16] at usb_msd_cbw_command

var bit usb_host_direction at usb_msd_cbw_flags : 7 -- direction the host wishes to transefer
const USB_HOST_DIRECTION_RECEIVE = TRUE
const USB_HOST_DIRECTION_SEND = FALSE

-- CSW variables
const USB_MSD_CSW = 0x53425355      -- signature that helps identify data packet as a CSW
var dword usb_msd_csw_signature = 0 -- relate CSW with a SBW at the end of packet
var byte usb_msd_csw_signature_[4] at usb_msd_csw_signature
var dword usb_msd_csw_tag = 0
var byte usb_msd_csw_tag_[4] at usb_msd_cbw_tag
var dword usb_msd_data_residue = 0
var byte usb_msd_data_residue_[4] at usb_msd_data_residue
var byte usb_msd_csw_status = 0          -- status of the command excecuted

-- status values for usb_msd_csw_status
const USB_MSD_CSW_STATUS_FAIL = 0x01     -- comand failed)
const USB_MSD_CSW_STATUS_SUCCESS = 0x00  -- command success

-- MSD commands we may get from host
const byte USB_MSD_INQUIRY                       = 0x12
const byte USB_MSD_READ_FORMAT_CAPACITY          = 0x23			
const byte USB_MSD_READ_CAPACITY                 = 0x25
const byte USB_MSD_READ_10                       = 0x28
const byte USB_MSD_WRITE_10                      = 0x2a
const byte USB_MSD_REQUEST_SENSE                 = 0x03
const byte USB_MSD_MODE_SENSE                    = 0x1a
const byte USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL  = 0x1e
const byte USB_MSD_TEST_UNIT_READY               = 0x00
const byte USB_MSD_VERIFY                        = 0x2f
const byte USB_MSD_STOP_START                    = 0x1b

-- Request Sense variables
var byte usb_msd_sense_response_valid
var bit*7 usb_msd_sense_response_code at usb_msd_sense_response_valid : 0 -- bits 0..6
var bit usb_msd_sense_valid at usb_msd_sense_response_code : 7 -- bit 7
--
var byte usb_msd_sense_obsolete
--
var byte usb_msd_sense_filemark_eom_ili_reserved_key
var bit usb_msd_sense_filemark  at usb_msd_sense_filemark_eom_ili_reserved_key : 7
var bit usb_msd_sense_eom       at usb_msd_sense_filemark_eom_ili_reserved_key : 6
var bit usb_msd_sense_ili       at usb_msd_sense_filemark_eom_ili_reserved_key : 5
var bit usb_msd_sense_reserved  at usb_msd_sense_filemark_eom_ili_reserved_key : 4
var bit*4 usb_msd_sense_key     at usb_msd_sense_filemark_eom_ili_reserved_key : 0
--
var dword usb_msd_sense_information
var byte usb_msd_sense_information_[4] at usb_msd_sense_information
--
var byte usb_msd_sense_add_sense_len
--
var dword usb_msd_sense_command_spacific
var byte usb_msd_sense_command_spacific_[4] at usb_msd_sense_command_spacific
--
var byte usb_msd_sense_asc
var byte usb_msd_sense_ascq
var byte usb_msd_sense_fruc
var byte usb_msd_sense_key_specific[3]
var bit usb_msd_sense_key_specific_sksv at usb_msd_sense_key_specific[0] : 7

-- sense codes
const byte USB_MSD_SENSE_NOT_READY                        = 0x02
const byte USB_MSD_SENSE_MEDIUM_ERROR                     = 0x03
const byte USB_MSD_SENSE_ILLEGAL_REQUEST                  = 0x05
const byte USB_MSD_SENSE_UNIT_ATTENTION                   = 0x06
const byte USB_MSD_SENSE_ASC_LOGICAL_BLOCK_OUT_OF_RANGE   = 0x21
const byte USB_MSD_SENSE_ASCQ_LOGICAL_BLOCK_OUT_OF_RANGE  = 0x00
const byte USB_MSD_SENSE_ASC_MEDIUM_NOT_PRESENT           = 0x3A
const byte USB_MSD_SENSE_ASCQ_MEDIUM_NOT_PRESENT          = 0x00
const byte USB_MSD_SENSE_ASC_DEVICE_WRITE_FAULT           = 0x03
const byte USB_MSD_SENSE_ASCQ_DEVICE_WRITE_FAULT          = 0x00
const byte USB_MSD_SENSE_ASC_READ_ERROR                   = 0x11
const byte USB_MSD_SENSE_ASCQ_READ_ERROR                  = 0x00
const byte USB_MSD_SENSE_ASC_WRITE_PROTECTED              = 0x27
const byte USB_MSD_SENSE_ASCQ_WRITE_PROTECTED             = 0x00
const byte USB_MSD_SENSE_ASC_INVALID_COMMAND_OPCODE       = 0x20
const byte USB_MSD_SENSE_ASCQ_INVALID_COMMAND_OPCODE      = 0x00
;const byte ASC_LOGICAL_UNIT_NOT_SUPPORTED = 0x25
;const byte ASCQ_LOGICAL_UNIT_NOT_SUPPORTED = 0x00
;const byte ASC_LOGICAL_UNIT_DOES_NOT_RESPOND = 0x05
;const byte ASCQ_LOGICAL_UNIT_DOES_NOT_RESPOND = 0x00
;const byte ASC_MEDIUM_NOT_PRESENT = 0x3a
;const byte ASCQ_MEDIUM_NOT_PRESENT = 0x00
;const byte ASC_LOGICAL_UNIT_NOT_READY_CAUSE_NOT_REPORTABLE = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_CAUSE_NOT_REPORTABLE = 0x00
;const byte ASC_LOGICAL_UNIT_IN_PROCESS = 0x04
;const byte ASCQ_LOGICAL_UNIT_IN_PROCESS = 0x01
;const byte ASC_LOGICAL_UNIT_NOT_READY_INIT_REQD = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_INIT_REQD = 0x02
;const byte ASC_LOGICAL_UNIT_NOT_READY_INTERVENTION_REQD = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_INTERVENTION_REQD = 0x03
;const byte ASC_LOGICAL_UNIT_NOT_READY_FORMATTING = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_FORMATTING = 0x04
;const byte ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE = 0x21
;const byte ASCQ_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE = 0x00
;const byte ASC_WRITE_PROTECTED = 0x27

-- define debug if not defined yet and disable it.
if !defined(debug_data) then
   -- setup debug lib
   ;alias debug_data is serial_data
   var bit debug_data

   const bit DEBUG_MASTER_ENABLE = FALSE    -- enables debugging
   include debug
   --
   -- turn on and off debug levels.
   debug_lvl_0 = OFF  -- short debugging
   debug_lvl_1 = OFF  -- display data in/out
   debug_lvl_2 = OFF  -- display commands
   debug_lvl_3 = OFF  -- short debug info
   --
   var byte debug_text0[] = "DEBUG STARTED"
   debug_string(DEBUG_0,debug_text0)
   debug_crlf(DEBUG_0)
end if

-------------------------------------------------------------------------
-- Setup USB endpoints, endpoint 0 and 1 are required for a MSD class
-- If possible, don't define accross banks
-------------------------------------------------------------------------
const bit USB_EP0 = ENABLED
const byte USB_EP0_OUT_SIZE = 64
const word USB_EP0_OUT_ADDR = (USB_BASE_ADDRESS + 0x0010)
const byte USB_EP0_IN_SIZE  = 64
const word USB_EP0_IN_ADDR  = (USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )

var volatile byte usb_ep0in_buf[USB_EP0_IN_SIZE] at USB_EP0_IN_ADDR
var volatile byte usb_ep0out_buf[USB_EP0_OUT_SIZE] at USB_EP0_OUT_ADDR

const bit USB_EP1 = ENABLED
const byte USB_EP1_OUT_SIZE = 64
const word USB_EP1_OUT_ADDR = (USB_EP0_IN_ADDR + USB_EP0_IN_SIZE)
const byte USB_EP1_IN_SIZE  = 64
const word USB_EP1_IN_ADDR  =  (USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE) + 0x30
; note: I have added + 0x30 to USB_EP1_IN_ADDR since it would cross over a bank
;       otherwise. The lib may work, but jalv2 does not support arrays
;       defined over banks which may cause data loss during transfers.

const bit USB_EP2 = DISABLED
const bit USB_EP3 = DISABLED

var byte msd_tx_buffer[USB_EP1_IN_SIZE] at { 0x600 }
;var byte msd_tx_buffer[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR
;var volatile byte msd_tx_buffer[USB_EP1_IN_SIZE]

var volatile byte usb_ep1in_buf[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR
var volatile byte usb_ep1out_buf[USB_EP1_OUT_SIZE] at USB_EP1_OUT_ADDR

-- ---------------------------------------------------------------------
-- Default USB_DEVICE_DESCRIPTOR
-- -----------------------------------------------------------------------
const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] =
{
0x12, -- Size of this descriptor in bytes
0x01, -- Descriptor Type - DEVICE
0x00, 0x02, -- USB Specification Release Number
0x00, -- Class is specified in the interface level
0x00, -- Subclass is specified at interface level
0x00, -- Protocol isspecified at interface level
USB_EP0_OUT_SIZE, -- Maximum packet size for endpoint zero
0x04, 0xD8, -- Vendor ID - Assigned by the USB-IF - Microchip Technology
0x09, 0x01, -- Product ID - assigned by vendor
0x00, 0x01, -- Device release number in BCD - assigned by vendor 1.00
0x01, -- Index of string descriptor describing the manufacturer
0x02, -- Index of string descriptor describing this product
0x00, -- Index of string descriptor describing the device.s serial number
0x01  -- Number of possible configurations
}

-- -----------------------------------------------------------------------
-- Default USB_CONFIGURATION_DESCRIPTOR
-- -----------------------------------------------------------------------
const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x07 + 0x07
const byte USB_CONFIGURATION_DESCRIPTOR[USB_CONFIGURATION_DESCRIPTOR_SIZE] =
{
--  Configuration Descriptor
0x09, -- Descriptor size in bytes
0x02, -- Descriptor type - CONFIGURATION
0x20, 0x00, -- Total length of data returned for this configuration
0x01, -- Number of interfaces supported by this configuration
0x01, -- Value to use as an argument to the SetConfiguration() request to select this configuration
0x00, -- Index of string descriptor describing this configuration. 0 = none
0x80, -- Configuration characteristics. Self-powered with no remote wakeup
0x32, -- Maximum power consumption

-- Bulk-Only Data Interface Descriptor
0x09, -- Descriptor size in bytes
0x04, -- Descriptor type - INTERFACE
0x00, -- Number of interface
0x00, -- Value used to select alternate setting for the interface identified in the prior field
0x02, -- Number of endpoints used by this interface (excluding endpoint zero)
0x08, -- Class code - Mass Storage
0x06, -- Subclass code - SCSI Transparent Command Set
0x50, -- Protocol - BULK-ONLY TRANSPORT
0x00, -- Index to string descriptor describing this interface - none

-- Endpoint Descriptor (ENDPOINT 1 IN)
0x07, -- Descriptor size in bytes
0x05, -- Descriptor type - ENDPOINT
0x81, -- The address of this endpoint on the USB device (bit 3..0 = endpoint number 1) (bit 7 = 1 = in)
0x02, -- Transfer type - Bulk
USB_EP1_IN_SIZE, 0x00, -- Maximum packet size
0x00, -- Does not apply to Bulk endpoints

-- Endpoint Descriptor (ENDPOINT 1 OUT)
0x07, -- Descriptor size in bytes
0x05, -- Descriptor type - ENDPOINT
0x01, -- The address of this endpoint on the USB device (bit 3..0 = endpoint number 1) (bit 7 = 0 = out)
0x02, -- Transfer type - Bulk
USB_EP1_OUT_SIZE, 0x00, -- Maximum packet size
0x00  -- Does not apply to Bulk endpoints
}


-- STRING 0
-- note: there may be bad packets till the host requests with wLength 4, but host will retry.
const byte USB_STRING0_SIZE = 0x04
const byte USB_STRING0[USB_STRING0_SIZE] =
{
   USB_STRING0_SIZE,            -- Descriptor size in bytes
   USB_DT_STRING,    -- Descriptor type - STRING
   0x09,            -- wLANGID[0] (low byte)
   0x04             -- wLANGID[0] (high byte)
}

-- String descriptor describing the manufacturer
const byte USB_STRING1_SIZE = 0x34
const byte USB_STRING1[USB_STRING1_SIZE] =
{
USB_STRING1_SIZE, -- Descriptor size in bytes
USB_DT_STRING,    -- Descriptor type - STRING
"M", 0x00,
"i", 0x00,
"c", 0x00,
"r", 0x00,
"o", 0x00,
"c", 0x00,
"h", 0x00,
"i", 0x00,
"p", 0x00,
" ", 0x00,
"T", 0x00,
"e", 0x00,
"c", 0x00,
"h", 0x00,
"n", 0x00,
"o", 0x00,
"l", 0x00,
"o", 0x00,
"g", 0x00,
"y", 0x00,
" ", 0x00,
"I", 0x00,
"n", 0x00,
"c", 0x00,
".", 0x00
}

-- String descriptor describing this product
const byte USB_STRING2_SIZE = 0x34
const byte USB_STRING2[USB_STRING2_SIZE] =
{
USB_STRING2_SIZE, -- Descriptor size in bytes
USB_DT_STRING,    -- bDescriptorType - STRING
"J", 0x00,
"a", 0x00,
"l", 0x00,
"l", 0x00,
"i", 0x00,
"b", 0x00,
" ", 0x00,
"M", 0x00,
"a", 0x00,
"s", 0x00,
"s", 0x00,
" ", 0x00,
"S", 0x00,
"t", 0x00,
"o", 0x00,
"r", 0x00,
"a", 0x00,
"g", 0x00,
"e", 0x00,
" ", 0x00,
"D", 0x00,
"r", 0x00,
"i", 0x00,
"v", 0x00,
"e", 0x00
}

-- String descriptor describing the device serial number
const byte USB_STRING3_SIZE = 0x1A
const byte USB_STRING3[USB_STRING3_SIZE] =
{
USB_STRING3_SIZE,            -- Descriptor size in bytes
USB_DT_STRING,   -- Descriptor type - STRING
"0", 0x00,
"2", 0x00,
"3", 0x00,
"4", 0x00,
"5", 0x00,
"6", 0x00,
"7", 0x00,
"8", 0x00,
"9", 0x00,
"A", 0x00,
"B", 0x00,
"C", 0x00
}

include usb_drv_core

-- DELAY must be checked -----------------------------------------------------------------------
procedure msd_wait_own_tx() is
   pragma inline
   var byte delay = 0
   while usb_msd_sae_owns_bit_in loop -- while host owns
      debug_char(0,"*")

      _usec_delay(10)    -- not sure why this is needed, I would prefer to remove it.

      -- exit on timeout
      delay = delay + 1
      if delay == 255 then
         exit loop
      end if

   end loop
end procedure

procedure msd_wait_own_rx() is
   pragma inline
   var byte delay = 0
   while usb_msd_sae_owns_bit_out loop -- while host owns
      debug_char(0,"/")

      -- exit on timeout
      delay = delay + 1
      if delay == 255 then
         exit loop
      end if

   end loop
end procedure


-- -----------------------------------------------------------------------
-- reset sense data. used for request sense command to
-- report our status
-- -----------------------------------------------------------------------
procedure usb_msd_reset_sense_data() is
   usb_msd_sense_response_valid       = 0x70
;   usb_msd_sense_response_code        = 0x70
;   usb_msd_sense_valid                = 0

   usb_msd_sense_obsolete             = 0

   usb_msd_sense_filemark_eom_ili_reserved_key = 0
   ;usb_msd_sense_key                  = 0
   ;usb_msd_sense_reserved             = 0
   ;usb_msd_sense_ili                  = 0
   ;usb_msd_sense_eom                  = 0
   ;usb_msd_sense_filemark             = 0

   usb_msd_sense_information          = 0
   usb_msd_sense_add_sense_len        = 0x0A
   usb_msd_sense_command_spacific     = 0
   usb_msd_sense_asc                  = 0
   usb_msd_sense_ascq                 = 0
   usb_msd_sense_fruc                 = 0  -- field replaceable unit code
   usb_msd_sense_key_specific[0] = 0 -- LSB
   usb_msd_sense_key_specific[1] = 0
   usb_msd_sense_key_specific[2] = 0
   ;usb_msd_sense_key_specific_sksv = 0 -- located at usb_msd_sense_key_specific[0] : 7 (already set)
end procedure

-- -----------------------------------------------------------------------
-- init procedure
-- -----------------------------------------------------------------------
procedure usb_msd_init() is
   usb_msd_reset_sense_data() -- reset sense data on startup
end procedure

-- -----------------------------------------------------------------------
-- Reset Callback. Must add the following lines to USB_DRV reset procedure
--   if defined (usb_reset_callback) then
--	     usb_reset_callback()
--   end if
--
-- with good code, you should not receive any resets from USB. You
-- will get a reset if you are slow to respond to a command
-- -----------------------------------------------------------------------
procedure usb_reset_callback() is
   -- release EP OUT uown to SIE to allow more data to arrive.
   usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

   -- no data left to send
   usb_msd_data_residue = 0

   -- wait for a command
   usb_msd_state = USB_MSD_STATE_WAIT

   const byte reset[] = "!!!RESET!!!"
   debug_string(0,reset)
   debug_crlf(0)
end procedure	

-- -----------------------------------------------------------------------
-- Check if the CBW received is valid.
-- -----------------------------------------------------------------------
function msd_cbw_is_valid() return bit is
   pragma inline
   var byte step

   -- check if we indeed got a CBW from the host
   usb_msd_cbw_signature_[0] = mem_pointer1
   usb_msd_cbw_signature_[1] = mem_pointer1
   usb_msd_cbw_signature_[2] = mem_pointer1
   usb_msd_cbw_signature_[3] = mem_pointer1

   if usb_msd_cbw_signature == USB_MSD_CBW then

      debug_char(0,"B")

      debug_crlf(1)
      const byte cbw_str[] = "CBW RECEIVED FROM HOST!"
      debug_string(1,cbw_str)
      debug_crlf(1)

      const byte cbw_str1[] = "usb_msd_cbw_signature: "
      debug_string(1,cbw_str1)
      debug_dword_hex(1, usb_msd_cbw_signature)
      debug_crlf(1)

      usb_msd_cbw_tag_[0] = mem_pointer1
      usb_msd_cbw_tag_[1] = mem_pointer1
      usb_msd_cbw_tag_[2] = mem_pointer1
      usb_msd_cbw_tag_[3] = mem_pointer1

      const byte cbw_str2[] = "usb_msd_cbw_tag: "
      debug_string(1,cbw_str2)
      debug_dword_hex(1, usb_msd_cbw_tag)
      debug_crlf(1)

   	usb_msd_cbw_data_transfer_length_[0] = mem_pointer1
   	usb_msd_cbw_data_transfer_length_[1] = mem_pointer1
   	usb_msd_cbw_data_transfer_length_[2] = mem_pointer1
   	usb_msd_cbw_data_transfer_length_[3] = mem_pointer1

      usb_msd_cbw_flags = mem_pointer1

      const byte cbw_str4[] = "usb_msd_cbw_flags: "
      debug_string(1,cbw_str4)
      debug_dword_dec(1, usb_msd_cbw_flags)
      debug_crlf(1)

      if usb_host_direction == USB_HOST_DIRECTION_RECEIVE then
         const byte host_expects_to_receive1[] = "Host Waiting To Receive: "
         debug_string(1,host_expects_to_receive1)
      else
         const byte host_expects_to_receive2[] = "Host Waiting To Send: "
         debug_string(1,host_expects_to_receive2)
      end if
      debug_dword_dec(1, usb_msd_cbw_data_transfer_length)
      const byte bytes_string[] = " Bytes"
      debug_string(1,bytes_string)
      debug_crlf(1)

      usb_msd_cbw_cbw_lun = mem_pointer1

      const byte cbw_str5[] = "usb_msd_cbw_cbw_lun: "
      debug_string(1,cbw_str5)
      debug_dword_dec(1, usb_msd_cbw_cbw_lun)
      debug_crlf(1)

      usb_msd_cbw_length = mem_pointer1

      const byte cbw_str6[] = "usb_msd_cbw_length: "
      debug_string(1,cbw_str6)
      debug_dword_dec(1, usb_msd_cbw_length)
      debug_crlf(1)

      -- get the command
      const byte cbw_str8[] = "CBWCB (command block): "
      debug_string(1,cbw_str8)

      for 16 using step loop
         usb_msd_cbw_command_[step] = mem_pointer1
         debug_byte_hex(1, usb_msd_cbw_command_[step])
         debug_char(1," ")
      end loop
      debug_crlf(1)

      return 1
   else
      return 0

      debug_crlf(1)
      const byte str1[] = "***BAD CBW***"
      debug_string(1, str1)

   end if
end function

-- -----------------------------------------------------------------------
-- Read from the storage device into USB_EP1 for output to the host.
-- -----------------------------------------------------------------------
procedure usb_msd_read(dword in address) is
   storage_raw_read_sector_address(address)
   while usb_msd_data_residue != 0 loop
         usb_msd_step64_ = 0
         for 8 loop

            mem_pointer1_address = USB_EP1_IN_ADDR
            msd_wait_own_tx() -- wait till we can write to the tx buffer
            --  read data from drive buffer in 64 byte chunks and place it
            --  into the usb tx buffer.   		
            var byte step2
            for 64 using step2 loop
               ;msd_tx_buffer[step2] = 0xAA -- for testing
               mem_pointer1 = storage_sector_buffer[usb_msd_step64_ + word(step2)]
               ;-- possible compiler bug with:
               ;msd_tx_buffer[step2] = storage_sector_buffer[usb_msd_step64_ + step2]
            end loop

            usb_msd_step64_ = usb_msd_step64_ + 64

            -- success if all data was read from the data device ok.
            usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS

            usb_msd_process_data(0)
         end loop
   end loop
end procedure

-- -----------------------------------------------------------------------
-- Do whatever needs to be done with a command received.
-- -----------------------------------------------------------------------
procedure usb_msd_command_received() is
   debug_char(0,"C")

   var byte step
   msd_wait_own_tx() -- wait till we can write to the tx buffer

   if usb_msd_cbw_command_[0] == USB_MSD_INQUIRY then
      debug_char(0,"I")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_INQUIRY"
      debug_string(2,command)
      debug_crlf(2)

      const byte usb_msd_inq[36] = {
   	0x00,	-- Peripheral Device Type
   	0x80, -- set removable media bit
   	0x04,	-- ISO version SPC-2
   	0x02,	-- Response Data Format SPC-2
   	0x1F,	-- Additional Length
   	0x00,	-- reserved
   	0x00,	-- bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
   		-- but as in case of other device, we are just using 00
   	0x00,	-- 00 obsolete, 0x80 for basic task queueing
   	"J","a","l","l","i","b"," "," ", 	-- Vendor Identification
   	"M","a","s","s"," ","S","t","o","r","a","g","e"," "," "," "," ", -- Product Identification
   	"0","0","0","1"} -- Product Revision

      -- set the data to send
      for count(usb_msd_inq) using step loop
         msd_tx_buffer[step] = usb_msd_inq[step]
      end loop

      usb_msd_data_residue = count(usb_msd_inq) -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- command success
      usb_msd_state = USB_MSD_STATE_DATA_IN           -- send data to host

   elsif usb_msd_cbw_command_[0] == USB_MSD_READ_FORMAT_CAPACITY then
      debug_char(0,"P")

      -- send capacities device can be formatted in.

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_FORMAT_CAPACITY"
      debug_string(2,command)
      debug_crlf(2)

      -- constants
      const byte UNFORMATTED_MEDIA     = 0b01
      const byte FORMATTED_MEDIA       = 0b10
      const byte NO_CARTRIDGE_IN_DRIVE = 0b11

      -- Capacity List Header
      msd_tx_buffer[0] = 0x00
      msd_tx_buffer[1] = 0x00
      msd_tx_buffer[2] = 0x00
      msd_tx_buffer[3] = 0x08	-- (8 bytes) x (1 descriptor)   	
      -- Current/Maximum Capacity Descriptor
      msd_tx_buffer[4] = usb_msd_num_of_blocks_[3];0x01   -- 5000 blocks (2.56MB to ensure FAT16)
      msd_tx_buffer[5] = usb_msd_num_of_blocks_[2] ;0x00
      msd_tx_buffer[6] = usb_msd_num_of_blocks_[1] ;0x13
      msd_tx_buffer[7] = usb_msd_num_of_blocks_[0] ;0x88
      msd_tx_buffer[8] = FORMATTED_MEDIA
      msd_tx_buffer[9] =  0x00 -- block size			-- 512 bytes per block
      msd_tx_buffer[10] = 0x02 -- block size			-- 512 bytes per block
      msd_tx_buffer[11] = 0x00 -- block size			-- 512 bytes per block

      usb_msd_data_residue = 12                       -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- command success
      usb_msd_state = USB_MSD_STATE_DATA_IN           -- waiting to send data to host


   elsif usb_msd_cbw_command_[0] == USB_MSD_READ_CAPACITY then
      debug_char(0,"P")

      -- send the size of the device (number of sectors)
      -- and also the sector size. (0x200 = 512)

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_CAPACITY"
      debug_string(2,command)
      debug_crlf(2)

      -- prepare the data response
      msd_tx_buffer[0] = usb_msd_num_of_blocks_[3];0x01 -- number of blocks	-- 5000 blocks
      msd_tx_buffer[1] = usb_msd_num_of_blocks_[2];0x00 -- number of blocks
      msd_tx_buffer[2] = usb_msd_num_of_blocks_[1];0x13 -- number of blocks
      msd_tx_buffer[3] = usb_msd_num_of_blocks_[0];0x88 -- number of blocks
      msd_tx_buffer[4] = 0x00 -- block size			-- 512 bytes per block
      msd_tx_buffer[5] = 0x00 -- block size			-- 512 bytes per block
      msd_tx_buffer[6] = 0x02 -- block size			-- 512 bytes per block
      msd_tx_buffer[7] = 0x00 -- block size			-- 512 bytes per block

      usb_msd_data_residue = 8 -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif usb_msd_cbw_command_[0] == USB_MSD_READ_10 then

      debug_char(0,"R")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_10"
      debug_string(2,command)
      debug_crlf(2)

      var dword address
      var byte address_[4] at address
      address_[0] = usb_msd_cbw_command_[5]
      address_[1] = usb_msd_cbw_command_[4]
      address_[2] = usb_msd_cbw_command_[3]
      address_[3] = usb_msd_cbw_command_[2]

      -- transfer data into USB_EP1
      for usb_msd_cbw_data_transfer_length / 512 loop
         usb_msd_data_residue = 512

         if USB_READ_TRANSFER_SPEED == USB_READ_SUPER_SPEED then
            while usb_msd_data_residue != 0 loop -- while there is data available
               storage_start_read(address) -- start reading
               for 512 / 64 loop -- read one sector
                  storage_read_sector_with_callback(64) -- read data
               end loop
               storage_stop_read() -- stop reading
            end loop
         else
            usb_msd_read(address)
         end if
         address = address + 1
      end loop

      usb_msd_data_residue = 0 -- done sending all data
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

      debug_char(0,"#")	

;         -- no point  in having (USB_MSD_SECTOR_READS == FALSE)
;         -- unless i enable this for writes
;
;         --  decode CBWCB to get LBA address and size to read from storage medium
;         --  then reads data in 512 byte chunks to be sent in 64 byte
;         --  chunks to host.
;
;         if USB_MSD_SECTOR_READS == TRUE then
;         elsif USB_MSD_SECTOR_READS == FALSE then -- Sector Reads
;            debug_crlf(2)
;            var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_10"
;            debug_string(2,command)
;            debug_crlf(2)
;
;            usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host
;
;            var dword address
;            var byte address_[4] at address
;            address_[0] = usb_msd_cbw_command_[5]
;            address_[1] = usb_msd_cbw_command_[4]
;            address_[2] = usb_msd_cbw_command_[3]
;            address_[3] = usb_msd_cbw_command_[2]
;
;            var word step = 0
;            var dword sector_step = 0
;
;            for usb_msd_cbw_data_transfer_length / 512 loop
;               storage_start_read(address + sector_step)
;               sector_step = sector_step + 1
;
;               usb_msd_data_residue = 512
;
;               while usb_msd_data_residue != 0 loop
;
;                  for 8 loop
;                     debug_crlf(0)
;                     debug_string(0,command)
;
;                    --  read data from drive buffer in 64 byte chunks and place it
;                     --  into the usb tx buffer.   		
;                     var byte step2
;                     for 64 using step2 loop
;                        ;msd_tx_buffer[step2] = 0xAA
;                        msd_tx_buffer[step2] = storage_raw_data_byte
;                     end loop
;
;                     -- success if all data was read from the data device ok.
;                     usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
;
;                     usb_msd_process_data(1)
;
;                  end loop
;
;               end loop
;               usb_msd_data_residue = 0 -- done sending all data
;               storage_stop_read() -- stop reading if already reading
;            end loop
;      end if

   elsif usb_msd_cbw_command_[0] == USB_MSD_WRITE_10 then		
      -- decode CBWCB to get LBA address and size to write to sd card
      -- then reads in 64 byte chunks from host to be written to the sd
      -- card in 512 byte chunks via out callback.

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_WRITE_10"
      debug_string(2,command)
      debug_crlf(2)

      debug_char(0,"X")

      usb_msd_address_[0] = usb_msd_cbw_command_[5]
      usb_msd_address_[1] = usb_msd_cbw_command_[4]
      usb_msd_address_[2] = usb_msd_cbw_command_[3]
      usb_msd_address_[3] = usb_msd_cbw_command_[2]

      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_cbw_data_transfer_length)
      debug_char(0,")")


      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_address)
      debug_char(0,")")


      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_data_residue)
      debug_char(0,")")

      usb_msd_sector_step_ = 0
      usb_msd_step64_ = 0

      -- release EP OUT uown to SIE to allow data to arrive.
      usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

      -- see out callback for the next write steps.

      debug_char(0,"W")
      debug_char(0,"R")

   elsif usb_msd_cbw_command_[0] == USB_MSD_REQUEST_SENSE then	
      debug_char(0,"S")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_REQUEST_SENSE"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_sense_valid = 0
      msd_tx_buffer[0] = usb_msd_sense_response_valid
      msd_tx_buffer[1] = usb_msd_sense_obsolete

      ;usb_msd_sense_filemark =
      ;usb_msd_sense_eom =
      ;usb_msd_sense_ili =
      ;usb_msd_sense_reserved =
      ;usb_msd_sense_key =
      msd_tx_buffer[2] = usb_msd_sense_filemark_eom_ili_reserved_key

      msd_tx_buffer[3] = usb_msd_sense_information_[0]
      msd_tx_buffer[4] = usb_msd_sense_information_[1]
      msd_tx_buffer[5] = usb_msd_sense_information_[2]
      msd_tx_buffer[6] = usb_msd_sense_information_[3]

      msd_tx_buffer[7] = usb_msd_sense_add_sense_len

      msd_tx_buffer[8] = usb_msd_sense_command_spacific_[0]
      msd_tx_buffer[9] = usb_msd_sense_command_spacific_[1]
      msd_tx_buffer[10] = usb_msd_sense_command_spacific_[2]
      msd_tx_buffer[11] = usb_msd_sense_command_spacific_[3]

      msd_tx_buffer[12] = usb_msd_sense_asc
      msd_tx_buffer[13] = usb_msd_sense_ascq
      msd_tx_buffer[14] = usb_msd_sense_fruc
      msd_tx_buffer[15] = usb_msd_sense_key_specific[0]
      msd_tx_buffer[16] = usb_msd_sense_key_specific[1]
      msd_tx_buffer[17] = usb_msd_sense_key_specific[2]

      usb_msd_data_residue = 18	-- size of this response
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif usb_msd_cbw_command_[0] == USB_MSD_MODE_SENSE then	
      debug_char(0,"M")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_MODE_SENSE"
      debug_string(2,command)
      debug_crlf(2)
	
   	msd_tx_buffer[0] = 0x03
   	msd_tx_buffer[1] = 0x00
   	msd_tx_buffer[2] = 0x00
   	msd_tx_buffer[3] = 0x00

      usb_msd_data_residue = 4	
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- waiting to send data to host
      usb_msd_state = USB_MSD_STATE_DATA_IN
    	
   elsif usb_msd_cbw_command_[0] == USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL then
      debug_char(0,"A")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      usb_msd_sense_key = USB_MSD_SENSE_NOT_READY
      usb_msd_data_residue = 0
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif usb_msd_cbw_command_[0] == USB_MSD_TEST_UNIT_READY then
      debug_char(0,"U")
      -- only send back csw with sucess or failure depending
      -- on state of the storage device

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_TEST_UNIT_READY"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_reset_sense_data()

      const byte MEDIA_READY = TRUE

      if MEDIA_READY == TRUE then
         usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      else
         ;gblSenseData_SenseKey = S_UNIT_ATTENTION;
         ;gblSenseData_ASC = ASC_MEDIUM_NOT_PRESENT;
         ;gblSenseData_ASCQ = ASCQ_MEDIUM_NOT_PRESENT;

         usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      end if

      usb_msd_data_residue = 0	           -- no data to send, only csw
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif usb_msd_cbw_command_[0] == USB_MSD_VERIFY then
      debug_char(0,"V")
      -- just reply success with csw, for media ok

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_VERIFY"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_data_residue = 0	           -- no data to send, only csw
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host
      	 		
   elsif usb_msd_cbw_command_[0] == USB_MSD_STOP_START then
      debug_char(0,"S")
      -- just reply success with csw

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_STOP_START"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_data_residue = 0	            -- no data to send, only csw
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN  -- waiting to send data to host
   else
      debug_char(0,"D")
      -- Hey! I don't know that command!

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - DON'T KNOW THIS COMMAND!"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_reset_sense_data()
      usb_msd_sense_key = USB_MSD_SENSE_ILLEGAL_REQUEST
      usb_msd_sense_asc = USB_MSD_SENSE_ASC_INVALID_COMMAND_OPCODE
      usb_msd_sense_ascq = USB_MSD_SENSE_ASCQ_INVALID_COMMAND_OPCODE
      usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      usb_msd_data_residue = 0x00	
      usb_msd_state = USB_MSD_STATE_DATA_IN	
   end if

end procedure

-- -----------------------------------------------------------------------
-- Handeles data going out from PIC and into the host.
-- -----------------------------------------------------------------------
procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline

   -- report that data is going into the host
   -- and which endpoint
   if debug_lvl_1 == TRUE then
      debug_crlf(1)
      const byte str[] = "--- EP data in: "
      debug_string(1,str)
      debug_byte_dec(1,byte_count)
      const byte str2[] = " bytes, on endpoint "
      debug_string(1,str2)
      debug_byte_dec(1, end_point )
      debug_crlf(1)
      const byte str3[] = " MSD STATE: "
      debug_string(1,str3)
      debug_byte_dec(1,usb_msd_state)
      debug_crlf(1)
   end if

   if debug_lvl_2 == TRUE then
      -- send data to the serial port for debugging
      -- not really needed since USB libs also have this debugging.
      var byte step
      for byte_count using step loop
         debug_byte_hex(1,msd_tx_buffer[step])
         debug_char(1," ")
      end loop
   end if

   debug_crlf(2) -- crlf
end procedure

procedure usb_msd_write(dword in address) is

   ;mem_pointer1_address = buffer_addr -- already in usb_ep_data_out_callback()
   ;msd_wait_own_rx() -- wait till we can read from the receive buffer

   if usb_msd_step64_ == 0 then
       storage_start_write(address)
   end if

   -- write data to sector buffer
   if USB_WRITE_TRANSFER_SPEED == USB_WRITE_SUPER_SPEED then
      storage_write_sector_with_callback(64)
   else
      for 64 using usb_msd_step_byte_ loop
         storage_sector_buffer[usb_msd_step64_ + word(usb_msd_step_byte_)] = mem_pointer1
      end loop
   end if

   usb_msd_step64_ = usb_msd_step64_ + 64

   -- allow host to send more
   usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

   if usb_msd_step64_ == 512 then
      -- write sector buffer to storage device
      if !(USB_WRITE_TRANSFER_SPEED == USB_WRITE_SUPER_SPEED) then
         storage_raw_write_sector()
      end if
      storage_stop_write()

      usb_msd_cbw_data_transfer_length = usb_msd_cbw_data_transfer_length - 512
   end if

end procedure

--------------------------------------------------------------------------------
-- Callback from your storage device library. The fastest way to write data.
--------------------------------------------------------------------------------
procedure usb_write_callback() is
   pragma inline
   if STORAGE_DEVICE == SD_CARD then
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
      spi_master = mem_pointer1
   else
      _error "This storage device is not supported by the USB_MSD lib with USB_WRITE_SUPER_SPEED"
   end if
end procedure

-- -----------------------------------------------------------------------
-- Handeles data going out of host to the PIC.
-- -----------------------------------------------------------------------
procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline

   debug_char(0,"Z")

   -- We received data on endpoint 1.
   if (end_point == 1) then

      -- report that data is comming from the host
      -- and which endpoint
      if debug_lvl_1 == TRUE then
         debug_crlf(1)
         const byte str[] = "--- EP data out: "
         debug_string(1,str)
         debug_byte_dec(1,byte_count)
         const byte str2[] = " bytes, on endpoint "
         debug_string(1,str2)
         debug_byte_dec(1, end_point )

         const byte str3[] = " MSD STATE: "
         debug_string(1,str3)
         debug_byte_dec(1, usb_msd_state)
      end if

      -- set buffer pointer to next data address
      mem_pointer1_address = buffer_addr

      if (usb_msd_state == USB_MSD_STATE_DATA_OUT) then
         debug_char(0,"O")


         usb_msd_write(usb_msd_address + usb_msd_sector_step_)

         if usb_msd_step64_ == 512 then

            usb_msd_sector_step_ = usb_msd_sector_step_ + 1
            usb_msd_step64_ = 0

            -- we're done!
            -- note: if the host has not sent all the data we expected,
            -- a reset will occur and we will be out of here anyways.
            if usb_msd_cbw_data_transfer_length == 0 then
               -- time to send CSW
               usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
               usb_msd_state = USB_MSD_STATE_DATA_IN
               usb_msd_data_residue = 0
               debug_char(0,"N")
            end if
         end if

      elsif  (usb_msd_state == USB_MSD_STATE_WAIT) then

         -- check if CBW is good.
         -- CBW hold a command and command parameters that comes from the host.
         if msd_cbw_is_valid() then -- check if CBW is ok

            -- check if host wants to send or receive data.
            if usb_host_direction == USB_HOST_DIRECTION_SEND then -- host is waiting to send data
               -- prepare to get data from host
               usb_msd_state = USB_MSD_STATE_DATA_OUT
            elsif usb_host_direction == USB_HOST_DIRECTION_RECEIVE then -- host is waiting to get data
               -- prepare to send data to host
               usb_msd_state = USB_MSD_STATE_DATA_IN
            end if

            const byte str3[] = " STATE: "
            debug_string(1,str3)
            debug_byte_dec(1, usb_msd_state)

            -- Do what we gotta do with the command received.
            usb_msd_command_received()

         else
            debug_char(0,"!")
            usb_prime_epx_out(1,USB_EP1_OUT_SIZE)
         end if

      end if

   else
      usb_prime_epx_out(0,USB_EP1_OUT_SIZE) -- do we need this?
   end if
end procedure

-- -----------------------------------------------------------------------
-- Respond to class specific requests
-- -----------------------------------------------------------------------
procedure usb_handle_class_request_callback() is

   const byte MSD_REQ_GET_MAX_LUN = 0xFE

   -- compiler issue, do local assignment to resolve
   var byte req01 = usb_sdp_request
   var word len = usb_sdp_length
   var word val = usb_sdp_value
   var byte valbt[2] at usb_sdp_value

   case (req01) of
   MSD_REQ_GET_MAX_LUN:
      block
         var byte send_bytes[1] = {0}

         usb_delivery_bytes_max_send = 0xFF
         usb_delivery_bytes_to_send = 1
         _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, send_bytes, usb_delivery_bytes_to_send )
         usb_delivery_buffer_size = USB_EP0_IN_SIZE
         -- usb_delivery_bytes_to_send
         usb_control_mode = USB_CM_CTRL_READ_DATA_STAGE
         usb_delivery_bytes_sent = 0
         var bit dts_bit at usb_bd0in_stat : USB_BDSTATUS_DTS
         dts_bit = low				

         -- AF ISO OF PRIME
         usb_send_data_chunk()
      end block
   end case
end procedure

include usb_drv

-- -----------------------------------------------------------------------
-- send data to the host
-- -----------------------------------------------------------------------
procedure msd_send_data(byte in size, bit in do_copy, bit in wait_own) is
   pragma inline

   debug_char(0,"*")

   -- note: I don't like blocking loops!
   -- does usb_send_data do this?
   if wait_own == TRUE then
      msd_wait_own_tx()
   end if

   debug_char(0,"*")


   if do_copy == TRUE then
      -- send the array of data (msd_tx_buffer). It will be sent next time
      -- usb_handle_isr() -> usb_ep_data_in_callback are called.

      ;-- copy the array to the bulk endpoiint (endpoint 1)
      ;var byte index
   	;for size using index loop
   ;		msd_tx_test_buffer[index] = msd_tx_buffer[index]
   ;	end loop
   	
      -- copy the array to the bulk endpoiint (endpoint 1)
      mem_pointer1_address = USB_EP1_IN_ADDR
      var byte index
   	for size using index loop
   	   ;serial_data = msd_tx_buffer[index]
   		mem_pointer1 = msd_tx_buffer[index]
   	end loop
   end if

   -- send the data
	usb_bd1in_addr = USB_EP1_IN_ADDR
	
	usb_bd1in_cnt = size
	var volatile bit dts_bit at usb_bd1in_stat : USB_BDSTATUS_DTS

	if (dts_bit) then
		usb_bd1in_stat = 0b_1000_1000
	else
		usb_bd1in_stat = 0b_1100_1000
	end if

end procedure

-- -----------------------------------------------------------------------
-- send command status wrapper.
-- basically sends the status of a command that
-- was completed by the PIC.
-- -----------------------------------------------------------------------
procedure usb_send_csw() is

   ;msd_wait_own_tx()

   -- send csw (31 bytes)
   msd_tx_buffer[0] = 0x55
   msd_tx_buffer[1] = 0x53
   msd_tx_buffer[2] = 0x42
   msd_tx_buffer[3] = 0x53
   msd_tx_buffer[4] = usb_msd_cbw_signature_[0]
   msd_tx_buffer[5] = usb_msd_cbw_signature_[1]
   msd_tx_buffer[6] = usb_msd_cbw_signature_[2]
   msd_tx_buffer[7] = usb_msd_cbw_signature_[3]
   msd_tx_buffer[8] = usb_msd_cbw_tag_[0]
   msd_tx_buffer[9] = usb_msd_cbw_tag_[1]
   msd_tx_buffer[10] = usb_msd_cbw_tag_[2]
   msd_tx_buffer[11] = usb_msd_cbw_tag_[3]
   msd_tx_buffer[12] = usb_msd_csw_status

   -- send the CBW.
   msd_send_data(13,1,1)
   ;usb_send_data(1, msd_tx_buffer, 13 , low)

   -- the command is completed, wait for the next command.
   usb_msd_state = USB_MSD_STATE_WAIT
	
   ;usb_handle_isr()

   -- release EP OUT uown to SIE to allow more data to arrive.
   usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

   debug_char(0,"W")
end procedure

-- -----------------------------------------------------------------------
-- set the amount of data to be sent to the host through msd_send_data
-- and update the amount of data left to be sent.
-- -----------------------------------------------------------------------
procedure usb_msd_process_data(byte in do_copy) is
   debug_char(0,"E")

   -- if there is more the 64 bytes to be sent (the size of the in endpoint)
   if (usb_msd_data_residue >= 64) & (usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS) then

      debug_crlf(2)
      var byte command[] = "SENDING 64 BYTES OF DATA, "
      debug_string(2,command)
      debug_dword_dec(2,usb_msd_data_residue - 64)
      var byte bytes_left[] = " BYTES LEFT!"
      debug_string(2,bytes_left)

      -- subtract 64 bytes from what is left to send.
      usb_msd_data_residue = usb_msd_data_residue - 64
      -- send 64 bytes of data
      msd_send_data(64,do_copy,1)

   elsif usb_msd_data_residue != 0 then -- if there is less then 64 bytes to send, or if there was an error
      if usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS then
         -- wait till data has been sent

            debug_crlf(2)
            var byte command[] = "SENDING "
            debug_string(2,command)
            debug_byte_dec(1,byte(usb_msd_data_residue))
            var byte command2[] = " BYTES OF DATA!!"
            debug_string(2,command2)
            debug_crlf(2)

            -- send data that was expected by host
            ;usb_send_data(1, msd_tx_buffer, byte(usb_msd_data_residue), low )

            msd_send_data(byte(usb_msd_data_residue),do_copy,1)
            usb_msd_data_residue = 0
      elsif usb_msd_csw_status == USB_MSD_CSW_STATUS_FAIL then
         -- if there was an error (usually during reading or writing data)
         -- at the moment, there should be no USB_MSD_CSW_STATUS_FAIL,
         -- unless we get a unsupported command.

         debug_crlf(2)
         var byte command[] = "STATUS FAIL!!"
         debug_string(2,command)
         debug_crlf(2)

         -- if the host is expecting more data
         if (usb_msd_data_residue >= 64) then   		
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for 64 using step loop
               msd_tx_buffer[step] = 0
            end loop

            -- send data
            msd_send_data(64,do_copy,1)
            usb_msd_data_residue = usb_msd_data_residue - 64
            usb_msd_data_residue = 0
         else                                   		                  ------------------- may be more then 64 bytes to send???
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for usb_msd_data_residue using step loop
               msd_tx_buffer[step] = 0
            end loop

            -- send data
            msd_send_data(byte(usb_msd_data_residue),do_copy,1)
            usb_msd_data_residue = 0
         end if
      end if
   end if

   -- see if there is anything else waiting
   usb_handle_isr()	
end procedure

-- -----------------------------------------------------------------------
-- Poll USB MSD for tasks
-- -----------------------------------------------------------------------
procedure usb_msd_tasks() is
   -- Servicing Hardware
   -- use polling method

   usb_handle_isr()

   -- If we have data to send to the host
   if (usb_msd_state == USB_MSD_STATE_DATA_IN) then

      -- if there is no more data to send
      ;if usb_msd_cbw_data_transfer_length == 0 then
      if usb_msd_data_residue == 0 then
         debug_crlf(2)
         debug_crlf(2)
         var byte command[] = "Sending CSW!"
         debug_string(2,command)

         -- finnished sending the data, now send the status
         usb_send_csw()

      else
         -- if there is data to send
         -- set the amount of data to be sent to the host through msd_send_data
         -- and update the amount of data left to be sent.
         usb_msd_process_data(1)
      end if

   elsif !usb_msd_sae_owns_bit_in & (usb_msd_state == USB_MSD_STATE_WAIT) then
      -- do nothing, we are just waiting for data
      -- it will be received through next call of usb_handle_isr()
   elsif usb_msd_state == USB_MSD_STATE_DATA_OUT then
      -- not supported yet, so lets just go to wait state??
      -- the previous command received was probobly not supported anyways,
      -- so we should never be in this state.
      ;usb_msd_state = USB_MSD_STATE_WAIT
   end if
end procedure

-- setup the USB device
usb_setup()

-- enable USB device
usb_enable_module()

-- -----------------------------------------------------------------------
-- check if MSD is configured
-- -----------------------------------------------------------------------
alias msd_is_configured is usb_is_configured

-- -----------------------------------------------------------------------
-- Wait till msd is configured
-- -----------------------------------------------------------------------
procedure usb_msd_wait_configured() is
   while !msd_is_configured loop
      -- poll the usb ISR function on a regular base, in order to
      -- serve the USB requests
      usb_msd_tasks()
      -- check if USB device has been configured by the HOST
      if usb_is_configured()  then
         exit loop
      end if
   end loop
end procedure

-- -----------------------------------------------------------------------
-- USB read procedure, a callback from your chosen storage library.
-- also see storage_read_callback() below.
-- Gets run by a call to storage_read_sector_address_with_callback()
-- -----------------------------------------------------------------------
procedure usb_read_callback() is
   pragma inline
   if STORAGE_DEVICE == SD_CARD then
      mem_pointer1_address = USB_EP1_IN_ADDR
      msd_wait_own_tx() -- wait till we can write to the tx buffer
      --  read data from drive buffer in 64 byte chunks and place it
      --  into the usb tx buffer.   		

      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master
      mem_pointer1 = spi_master

      usb_msd_step64_ = usb_msd_step64_ + 64

      -- success if all data was read from the data device ok.
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS

      usb_msd_process_data(0)

   else
      _error "This storage device is not supported by the USB_MSD lib with USB_READ_SUPER_SPEED"
   end if
end procedure

-- -----------------------------------------------------------------------
-- alias the storage_read_callback() to usb_read_callback()
-- for faster reads.
-- -----------------------------------------------------------------------
if USB_READ_TRANSFER_SPEED == USB_READ_SUPER_SPEED then
   procedure storage_read_callback(word in chunk_size) is
      pragma inline
      usb_read_callback()
   end procedure
end if


-- -----------------------------------------------------------------------
-- alias the storage_WRITE_callback() to usb_WRITE_callback()
-- for faster writes.
-- -----------------------------------------------------------------------
if USB_WRITE_TRANSFER_SPEED == USB_WRITE_SUPER_SPEED then
   procedure storage_write_callback(word in chunk_size) is
      pragma inline
      usb_write_callback()
   end procedure
end if

-- -----------------------------------------------------------------------
-- Print the selected transfer speed settings.
-- Several transfer speeds exist for testing better performance
-- and reliability.
-- -----------------------------------------------------------------------
;_SUPER_SPEED -- uses memory pointer for extra speed,
;                                     -- data direct from devide to USB endpoint, no buffer array
;_EXTRA_SPEED -- uses storage device extra speed routines,
;                                     -- with 512 byte buffer array
;_NORMAL_SPEED -- uses normal storage device routines
;                                     -- with 512 byte buffer array.
procedure usb_print_speeds() is
   print_string(serial_data, "MSD Read Speed: ")
   if USB_READ_TRANSFER_SPEED == USB_READ_NORMAL_SPEED then
      print_string(serial_data, "USB_READ_NORMAL_SPEED")
   end if
   if USB_READ_TRANSFER_SPEED == USB_READ_EXTRA_SPEED then
      print_string(serial_data, "USB_READ_EXTRA_SPEED")
   end if
   if USB_READ_TRANSFER_SPEED == USB_READ_SUPER_SPEED then
      print_string(serial_data, "USB_READ_SUPER_SPEED")
   end if
   print_crlf(serial_data)

   print_string(serial_data, "MSD write Speed: ")
   if USB_WRITE_TRANSFER_SPEED == USB_WRITE_NORMAL_SPEED then
      print_string(serial_data, "USB_WRITE_NORMAL_SPEED")
   end if
   if USB_WRITE_TRANSFER_SPEED == USB_WRITE_EXTRA_SPEED then
      print_string(serial_data, "USB_WRITE_EXTRA_SPEED")
   end if
   if USB_WRITE_TRANSFER_SPEED == USB_WRITE_SUPER_SPEED then
      print_string(serial_data, "USB_WRITE_SUPER_SPEED")
   end if
   print_crlf(serial_data)
end procedure
