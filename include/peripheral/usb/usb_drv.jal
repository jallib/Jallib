-- -----------------------------------------------------------------------------
-- Title: USB driver library
-- Author: Albert Faber, Copyright (c) 2008..2021, all rights reserved.
-- Adapted-by: Rob Jansen
-- Compiler: 2.5r5
-- 
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
-- 
-- Description: This file contains the lowl level USB driver routines. It constrols
-- the USB serial interface engine, by managing the input and output transfers,
-- and calling the defined callback function when required.
--
-- Sources: http://www.usb.org ; for USB specifications
--          http://www.lvr.com/usbc.htm ; a lot of information about USB
--          http://www.beyondlogic.org/ ; also a nice with with useful information
--
-- Notes: There are two options to use the USB driver:
--        1) Without interrupts by frequently calling 'usb_serial_flush()' 
--           frequently in the main loop.
--        2) Using interrupts to make timing less critical. In that case no 
--           calls to 'usb_serial_flush()' are needed. 
--           This can be activated by defining: const USB_INTERRUPT_DRIVEN = TRUE    
--
--           Do not use the interrupt driven feature when debugging the driver.
--

-- USB_PULLUP_OPTION, defines the USB PULL UP configuration
-- value can be set to USB_PULLUP_ENABLE to enable the USB pull up resistors
-- value can be set to USB_PULLUP_DISABLE to disable the USB pull up resistors
if defined( USB_PULLUP_OPTION ) == false then
   const byte USB_PULLUP_OPTION = USB_PULLUP_ENABLE
end if


-- USB_TRANSCEIVER_OPTION, defines if the internal USB transeiver is enabled
-- value can be set to USB_INTERNAL_TRANSCEIVER to enable the internal USB tranceiver
-- value can be set to USB_EXTERNAL_TRANSCEIVER to disable the internal USB tranceiver
if defined( USB_TRANSCEIVER_OPTION ) == false then
   const byte USB_TRANSCEIVER_OPTION = USB_INTERNAL_TRANSCEIVER
end if


-- USB_SPEED_OPTION, defines the USB speed (low or high speed USB)
-- value can be set to USB_LOW_SPEED to use low speed (1.5 Mbps) USB option
-- value can be set to USB_FULL_SPEED to use high speed (12 Mb-s) USB option
-- if not set we use full speed.
if defined( USB_SPEED_OPTION ) == false then
   const byte USB_SPEED_OPTION = USB_FULL_SPEED
end if


-- --------------------------------------------------------------------------------------
-- Internal procedure to handle standard USB device requests.
-- it will take care of the overall state of the device
-- -) performing USB buffer management
-- -) controlling the SIE
-- -) call the callback function if required
-- The usb_sdp_buffer contains the request as given by the SETUP package.
-- --------------------------------------------------------------------------------------
procedure _usb_handle_standard_request() is
   var volatile byte wbt_value[2] at usb_sdp_value
   var volatile byte wbt_length[2] at usb_sdp_length
   var byte index
   var bit own_bit at usb_bd0in_stat : USB_BDSTATUS_UOWN
   var bit dts_bit at usb_bd0in_stat : USB_BDSTATUS_DTS
   
   case usb_sdp_request of
      
      USB_REQUEST_GET_DESCRIPTOR:
      block
         if USB_DEBUG > 0 then
            print_string( serial_hw_data, " GD: ")
         end if
                 
         var byte descriptor_type = wbt_value[1] -- high byte is descriptor
         var byte descriptor_num  = wbt_value[0] -- low byte is particular descriptor
         usb_delivery_bytes_to_send = 0 -- Assume nothing needs to be sent
         
         if USB_DEBUG > 0 then
            print_byte_hex(serial_hw_data,  descriptor_type )
         end if
         
         case descriptor_type of
            USB_DT_DEVICE:
            block
               -- Copy device descriptor to delivery buffer.
               if USB_DEBUG > 0 then
                  print_string(serial_hw_data," Device ")
               end if
               usb_delivery_bytes_to_send = count( USB_DEVICE_DESCRIPTOR )
               _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_DEVICE_DESCRIPTOR, usb_delivery_bytes_to_send )
            end block	
            
            USB_DT_CONFIGURATION:
            block	
               -- Copy configuration descriptor to delivery buffer.
               if USB_DEBUG > 0 then
                  print_string(serial_hw_data," Config ");
               end if	
               usb_delivery_bytes_to_send = count( USB_CONFIGURATION_DESCRIPTOR )            
               _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_CONFIGURATION_DESCRIPTOR, usb_delivery_bytes_to_send )	
            end block
            
            USB_DT_STRING:
            block			
               -- Copy string to delivery buffer.               
               if USB_DEBUG > 0 then
                  print_string(serial_hw_data," String: ");                 
                  print_byte_hex(serial_hw_data, descriptor_num)
               end if
               
               if defined(USB_STRING0) == true then					
                  if (descriptor_num == 0 ) then
                     usb_delivery_bytes_to_send = count( USB_STRING0 )
                     _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_STRING0, usb_delivery_bytes_to_send )
                  end if
               end if
               if defined(USB_STRING1) == true  then					
                  if (descriptor_num == 1 ) then
                     usb_delivery_bytes_to_send = count( USB_STRING1 )
                     _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_STRING1, usb_delivery_bytes_to_send )
                  end if
               end if					
               if defined(USB_STRING2) == true then					
                  if (descriptor_num == 2 ) then
                     usb_delivery_bytes_to_send = count( USB_STRING2 )
                     _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_STRING2, usb_delivery_bytes_to_send )
                  end if
               end if				
               if defined(USB_STRING3) == true then					
                  if (descriptor_num == 3 ) then
                     usb_delivery_bytes_to_send = count( USB_STRING3 )
                     _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_STRING3, usb_delivery_bytes_to_send )
                  end if
               end if				
               if defined(USB_STRING4) == true then					
                  if (descriptor_num == 4 ) then
                     usb_delivery_bytes_to_send = count( USB_STRING4 )
                     _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_STRING4, usb_delivery_bytes_to_send )
                  end if
               end if				
            end block
            
            -- AF TODO?
            -- RJ: This is only needed when supporting both full speed and high speed,
            --     which is not the case (only full speed is supported by this SIE).
            -- USB_DT_DEVICE_QUALIFIER:
            -- block	
            -- end block

            USB_DT_HID_REPORT:
            block               
               if USB_DEBUG > 0 then
                  print_string(serial_hw_data," HID report ")
               end if	
                  -- Defined in USB HID generic device.
               if defined(USB_HID_REPORT1) then
                  usb_delivery_bytes_to_send = count( USB_HID_REPORT1 )
                  _usb_copy_array_to_ram( USB_IN_DELIVERY_BUFFER_LOC, USB_HID_REPORT1, usb_delivery_bytes_to_send )	
               end if
            end block
            
            otherwise
            block	
               if USB_DEBUG > 0 then					
                  print_string(serial_hw_data," !!HSTDREQ?? ")
               end if
            end block
                        
         end case -- descriptor_type
         
         -- Maybe data is prepared, if so send it. 
         if ( usb_delivery_bytes_to_send > 0 ) then
            -- We've got something. We have to send data in chucks of the maximum endpoint0 in buffer size.
            -- RJ: See remark in ' usb_send_data_chunk()' about buffer size.
            usb_delivery_buffer_size = USB_EP0_IN_SIZE
            
            if ( wbt_length[1] == 0  ) then
               -- Do not send more than allowed by the Host.
                usb_delivery_bytes_max_send = wbt_length[0]
            else
               -- We will never send more than the maximum size of usb_delivery_buffer size.
               usb_delivery_bytes_max_send = USB_DELIVERY_BUFFER_MAX_SIZE
            end if
            
            -- Prepare to send the data. Note that read means the Host reads from the MCU so the MCU
            -- sends to the Host. The control mode is set to USB_CM_CTRL_READ_DATA_STAGE so that 
            -- the remaining data can be sent in chunks if it does not fit in the endpoint buffer.
            usb_control_mode = USB_CM_CTRL_READ_DATA_STAGE
            usb_delivery_bytes_sent = 0

            -- RJ: When a setup package is received, it always starts with Data0 (even) so
            --     the DTS bit must be cleared.
            dts_bit = low				            
            -- AF ISO OF PRIME
            usb_send_data_chunk()
            
         else
            -- Stall it sent when the request is not supported.
            if USB_DEBUG > 0 then
               print_string(serial_hw_data," <stall> ")
            end if
            usb_stall_ep0();
         end if						
      end block
      
      -- This request is part of URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL
      -- or URB_FUNCTION_SYNC_CLEAR_STALL or URB_FUNCTION_SYNC_RESET_PIPE.
      -- The USB device should reset the data toggle and clear the STALL.       
      USB_REQUEST_CLEAR_FEATURE:
      block
         usb_delivery_buffer_size = USB_EP0_IN_SIZE
         usb_delivery_bytes_sent = 0
         usb_delivery_bytes_to_send = 0
         usb_delivery_bytes_max_send = 0
         -- Clear UOWN and DTS.
         own_bit = FALSE
         dts_bit = FALSE
         -- So we send an empty packet.
         usb_send_data_chunk()
      end block
     
      USB_REQUEST_SET_ADDRESS:
      block
         usb_address = wbt_value[0]
         if USB_DEBUG > 0 then
            print_string( serial_hw_data," SA:")
            print_byte_hex(serial_hw_data,  usb_address )
         end if 				
         usb_status = USB_STATUS_SET_ADDRESS
         
         -- Send a status ack - when we confirm that, THEN change address
         -- of this USB device. 
         -- RJ: I assume that AF means that the address is only set after
         --     the host has acknoweledged the response of the device, 
         --     which is done in usb_handle_transaction().
         usb_send_status_ack()
         usb_control_mode = USB_CM_CTRL_WRITE_SENDING_STATUS
      end block
      
      -- Set configuration is used to enable the device.
      USB_REQUEST_SET_CONFIGURATION:
      block
         if USB_DEBUG > 0 then
            print_string( serial_hw_data," SC: ")
         end if 			
         
         -- RJ: The control mode is used here to complete the request.
         --     See USB_PID_IN in usb_handle_transaction() where it 
         --     handles the acknowledge. It would have been cleaner to 
         --     give this mode its own value for setting the configuration
         --     so that the check 'if (usb_status == USB_STATUS_SET_ADDRESS)
         --     would not be needed in usb_handle_transaction(). 

         --AF: sdp.wValue & 0xff; -- MORE WORK see p136

         -- RJ: I think I understand what AF means. You have to check 
         --     if the bConfigurationValue matches the configuration
         --     which should match with the configuration value in the
         --     configuration description but there is only one
         --     configuration description so this check is ignored and
         --     we just call the only procedure that does the endpoint
         --     configuration usb_configure_endpoints().
         usb_control_mode = USB_CM_CTRL_WRITE_SENDING_STATUS
         usb_send_status_ack()
         
         usb_state = USB_STATE_CONFIGURED
         
         -- device is up - so now get the endpoints happy
         usb_configure_endpoints();
         
         -- and do a call back to let the app know we're ready. If not
         -- present then skip it.
         if defined( usb_device_configured_callback ) == true then
            usb_device_configured_callback()
         end if	
      end block
      
      USB_REQUEST_GET_INTERFACE:
      block
         if USB_DEBUG > 0 then
            print_string( serial_hw_data," GI ")
         end if	
         usb_control_mode = USB_CM_CTRL_READ_DATA_STAGE
         -- One alternative interface.
         usb_send_one_byte( 1 )
      end block
      
      USB_REQUEST_GET_STATUS:
      block
                  
         -- send two bytes
         if USB_DEBUG > 0 then	
            print_string(serial_hw_data," GS ")
         end if

         -- Status answer is 2 bytes long. 
         usb_send_one_byte(0) -- RJ: Must be 2 bytes?
         
         -- RJ: Why send one byte and not 2 bytes as given below? Seems
         --     this is not implemented. It is assumed that sending
         --     one byte means bus powered and no remote wake-up.
         --     Note that USB_SELF_POWERED is not used anywhere else. 
         --     This requires rework --> TODO.       

         if false then
            if USB_SELF_POWERED then
               usb_send_one_byte(1)
               usb_delivery_buffer[0] = 0x01	-- self powered
            else
               usb_delivery_buffer[0] = 0x00	-- bus powered
            end if
            
            -- Remote wake-up
            usb_delivery_buffer[1] = 0x00 -- RJ: Remote wakeup is a bit in position 0.
            
            usb_delivery_buffer_size = USB_EP0_IN_SIZE
            usb_delivery_bytes_sent = 0
            usb_delivery_bytes_to_send = 2
--            usb_delivery_bytes_max_send = 0 -- RJ: Previous version.
            usb_delivery_bytes_max_send = 2 -- RJ: This should be 2?.
            
            -- clear DTS in order to toggle it
            dts_bit = low
            usb_send_data_chunk()
            
         end if
         
      end block
            
      otherwise
      block
         -- Unknown or unsupported request. 
         if USB_DEBUG > 0 then
            print_string(serial_hw_data," ??SR ")
            print_byte_hex(serial_hw_data, usb_sdp_request)
         end if
      end block
      
   end case	
   
end procedure	


-- --------------------------------------------------------------------------------------
-- Internal procedure to handle the USB transactions
-- it will take care of the overall state of the device
-- -) performing USB buffer management
-- -) controlling the SIE
-- -) call the callback function if required
-- This function is called when the TRNIF flag is set. USTAT holds the 
-- endpoint information.
-- --------------------------------------------------------------------------------------
procedure _usb_handle_transaction() is
   
   var byte end_point
   var byte pid
   
   -- Get the endpoint from the USB status register for which there was a transaction.
   end_point = USTAT >> 3;
   
   
   if USTAT_DIR then
      -- The last transaction was an IN token (IN for the Host) so from device (PIC) 
      -- to Host.
      if USB_DEBUG_HIGH > 0 then
         print_crlf(serial_hw_data)
         print_string(serial_hw_data,"IN ")
         print_byte_hex(serial_hw_data,usb_bd0in_cnt)
         print_byte_hex(serial_hw_data,usb_bd0in_stat)
      end if		
      -- mask out the packet identifier (SIE mode, data returned to the MCU)
      pid = ( usb_bd0in_stat >> 2) & 0x0f
   else
      -- The last transaction was an OUT token (OUT for the Host) so from Host to
      -- device (PIC).
      if USB_DEBUG_HIGH > 0 then
         print_crlf(serial_hw_data)
         print_string(serial_hw_data,"OUT ")
         print_byte_hex(serial_hw_data,usb_bd0out_cnt)
         print_byte_hex(serial_hw_data,usb_bd0out_stat)
      end if
      -- mask out the packet identifier (SIE mode, data returned to the MCU)
      pid = (usb_bd0out_stat >> 2) & 0x0f          
   end if  -- USTAT_DIR
   
   if USB_DEBUG_HIGH > 0 then
      if (end_point != 0) then
         print_crlf(serial_hw_data)
         print_string(serial_hw_data, "E ")          
         print_byte_hex(serial_hw_data,  end_point )
         serial_hw_data = " "         
      end if
   end if
      
   if ( end_point == 0 ) then
      -- Endpoint 0 is reserved in every device and used for control purposes.   
      if USB_DEBUG_HIGH > 0 then
         -- Buffer descriptor out of endpoint 0 holds the bytes received.
         print_string( serial_hw_data," bytes: ")
         print_byte_hex(serial_hw_data, usb_bd0out_cnt)
      end if
            
      case pid of
         -- The setup packets are used for detection and configuration of the device.
         USB_PID_SETUP:
         block
            var byte src[8] at USB_EP0_OUT_ADDR -- Endpoint 0 out buffer.
            var byte idx
            
            -- Copy the received data stored in the endpoint 0 out buffer.
            for 8 using idx loop
               usb_sdp[idx ] = src[idx ]
            end loop
            
            if USB_DEBUG > 0 then
               print_crlf(serial_hw_data)
               serial_hw_write( "!" )
               for 8 using idx loop
                  print_byte_hex(serial_hw_data,  usb_sdp[ idx ] )
               end loop	
            end if
            
            -- RJ: After a SETUP is received the SIE token and packet processing is 
            -- disabled. Clear PKTDIS to enable before setting up the endpoint(s) again.
            UCON_PKTDIS = LOW		
            
            -- When a setup is received we need to clear the Stall and UOWN for 
            -- endpoint 0. This is not done by the hardware.
            usb_prime_ep0_out()

            if USB_DEBUG > 0 then              
               var volatile bit  dir_bit at usb_sdp_request_type : USB_DATA_STAGE_DIR_BIT
               
               if dir_bit then
                  print_string(serial_hw_data," DS=IN ")
               else
                  print_string(serial_hw_data," DS=OUT/NO ")
               end if
            end if
                        
            -- Obtain request type.
            case ( usb_sdp_request_type  & 0b_0110_0000 ) of

               (0b00 << USB_REQUEST_TYPE0_BIT ):
               block
                  -- Standard request.
                  if USB_DEBUG > 0 then
                     var byte masked_request = (usb_sdp_request_type & 0b00011111)
                     if (masked_request == 0x00) then
                        -- Device request.
                        print_string(serial_hw_data," 2dev ")
                     elsif (masked_request == 0x01) then	
                        -- Interface request.
                        print_string(serial_hw_data," 2int ")
                     elsif (masked_request == 0x02) then	
                         -- Endpoint request.
                        print_string(serial_hw_data," 2end ")
                     elsif (masked_request == 0x03 ) then	
                        -- Other request.
                        print_string(serial_hw_data," 2oth ")
                     end if
                     print_string(serial_hw_data," std ")
                  end if	
                  -- Handle the standard request.                  
                  _usb_handle_standard_request()                  
                 end block

               (0b01 << USB_REQUEST_TYPE0_BIT ):
               block					
                  -- Class request,
                  if USB_DEBUG > 0 then
                     print_string(serial_hw_data," class ")
                 end if
                  if defined( usb_handle_class_request_callback ) then
                     usb_handle_class_request_callback()
                  end if	
               end block

               (0b10 << USB_REQUEST_TYPE0_BIT ):
               block					
                  -- Vendor request.
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," vendor ")
                  end if
                  if defined( usb_handle_vendor_request_callback ) then
                     usb_handle_vendor_request_callback()
                  end if	
               end block

               otherwise
               block
                  -- Reserved type so unknown.                
                  if USB_DEBUG > 0 then
                     print_string(serial_hw_data," ??req t=")
                     print_byte_hex(serial_hw_data,usb_sdp_request_type)
                     serial_hw_write(" ")
                  end if	
               end block
            end case
         end block -- USB_PID_SETUP
                  
         -- Note that IN is from device to Host so sending data. Depending on 
         -- what we are doing this can also be just an acknowledge to the host.
         USB_PID_IN:
         block
            if USB_DEBUG > 0 then
               print_string( serial_hw_data," IN CM=")
               print_byte_hex(serial_hw_data,usb_control_mode)
            end if
             
            case usb_control_mode of
               USB_CM_CTRL_READ_DATA_STAGE:
               block
                  -- It's ours, so send next chunk of data. 
                  -- If there is no data anymore, an empty packet (zero data)
                  -- is sent which is the same as sending an acknowledge.
                  usb_send_data_chunk()				
               end block
               
               USB_CM_CTRL_WRITE_SENDING_STATUS:
               block
                  -- We are done after this action.
                  usb_control_mode = USB_CM_IDLE
                  if (usb_status == USB_STATUS_SET_ADDRESS) then
                     
                     if USB_DEBUG > 0 then
                        print_crlf(serial_hw_data)
                        print_string( serial_hw_data," addr to ")
                        print_byte_hex(serial_hw_data,usb_address)
                     end if
                     
                     usb_state = USB_STATE_ADDRESS
                     -- Set address of this USB device.
                     UADDR = usb_address
                     usb_status = USB_STATUS_IDLE
                  end if
                  
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," ----\n")
                  end if	
               end block
               
               USB_CM_CTRL_READ_AWAITING_STATUS:
               block
                  -- Must have been last IN of the read, so still waiting for status
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," last read, waiting status");
                  end if	
                  -- RJ: It looks as if this could become a hangup situation but the
                  --     driver does not get here. Most likely because this state
                  --     is commented out in usb_send_data_chunck(), otherwise add:
                  --     usb_control_mode = USB_CM_IDLE
               end block
               
               USB_CM_CTRL_READ_DATA_STAGE_CLASS:
               block
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," ctrl read ")
                  end if	
                  -- Must be more to come
                  if defined( usb_handle_class_ctrl_read_callback ) then
                     usb_handle_class_ctrl_read_callback();
                  end if	
               end block
               
               otherwise
               block
                  if USB_DEBUG > 0 then
                     print_string(serial_hw_data," ?? cm=")
                     print_byte_hex(serial_hw_data,  usb_control_mode )
                     serial_hw_data = " "
                  end if					
               end block
            end case
         end block -- USB_PID_IN
                  
         -- Ack from the host. Depending on the last action we are sending (read) or
         -- receiving (write) stuff.
         USB_PID_ACK:
         block
            if USB_DEBUG > 0 then
               print_string( serial_hw_data,"****A\n")
            end if
                       
            case usb_control_mode of
               USB_CM_CTRL_READ_DATA_STAGE: 
               block
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," &2 ")
                  end if
                  usb_send_data_chunk()
               end block
               
               USB_CM_CTRL_READ_DATA_STAGE_CLASS: 
               block
                  if defined( usb_handle_class_ctrl_read_callback ) then
                     usb_handle_class_ctrl_read_callback()
                  end if	
               end block
               USB_CM_CTRL_WRITE_SENDING_STATUS: 
               block
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," st sent ")
                  end if
                  usb_control_mode = USB_CM_IDLE
               end block

               -- RJ: Added for debugging.
               otherwise
               block
                  if USB_DEBUG > 0 then
                     print_string(serial_hw_data," ?? cm=")
                     print_byte_hex(serial_hw_data,usb_control_mode)
                     serial_hw_data = " "
                  end if					
               end block
            end case
         end block -- USB_PID_ACK
                  
         -- Note that OUT is from Host to de device so receiving data. 
         USB_PID_OUT:
         block
             
            if USB_DEBUG_HIGH > 0 then
               print_crlf(serial_hw_data)               
               print_string( serial_hw_data,"PID_OUT ")
               print_byte_hex(serial_hw_data,  usb_control_mode)
            end if
            
            case usb_control_mode of
               
               USB_CM_CTRL_READ_AWAITING_STATUS:
               block
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data," -xx-\n")
                  end if
                  usb_control_mode = USB_CM_IDLE
                  usb_prime_ep0_out()
               end block
               
               USB_CM_CTRL_WRITE_DATA_STAGE_CLASS:
               block
                  if defined( usb_handle_class_ctrl_write_callback ) then
                     usb_handle_class_ctrl_write_callback()
                     -- !! should include bc bits here for total count
                     -- this only works for 8 bit data packets
                     -- RJ: Currently the callback only supports changing line
                     --     settings so no need to set these bits.
                  end if	
                  usb_prime_ep0_out()
               end block
               
               USB_CM_CTRL_READ_DATA_STAGE:
               block
                  --print_string( serial_hw_data," Status early ");
                  usb_prime_ep0_out()
                  -- We are done with this one.
                  usb_control_mode = USB_CM_IDLE                 
               end block
               
               otherwise
               block					
                  if USB_DEBUG > 0 then
                     print_string( serial_hw_data, "??unk pid_OUT ")
                     print_byte_hex(serial_hw_data,  usb_control_mode )
                  end if	
                  usb_prime_ep0_out()
               end block
               
            end case
            
         end block

         -- Unknown PID.
         otherwise
         block
            if USB_DEBUG > 0 then
               print_string( serial_hw_data," UKPID = ")
            end if	
         end block			
      end case
      
   else -- end_point == 0
      -- Not endpoint 0.
      if USTAT_DIR then
         -- Last transaction was an IN token (so sending data to the Host).
         if USB_DEBUG_HIGH > 0 then
            print_string( serial_hw_data," EPDIN ")
            print_byte_hex(serial_hw_data, end_point)
            serial_hw_write( " " )
         end if
         
         if defined( usb_ep_data_in_callback ) then
            -- RJ: The parameters are not used, only end_point
            --     for now leave it.

            -- Find the start position of the end-point. End points
            -- are 4 bytes in size but we have both out endpoints and
            -- in endpoints and we have ping-pong buffers on all 
            -- endpoints except endpoint0.
            var byte idx = end_point * 8 
            var byte bcnt

            -- Skip the OUT endpoint. Point to the start of the IN endpoint.
            idx = idx + 4
            -- The byte count is at the position 1.
            bcnt = usb_bd_array[idx + 1]				
            
            -- Get the address of the endpoint buffer.
            var word addr
            var byte bt_addr[2] at addr           
            bt_addr[0] = usb_bd_array[idx + 2]
            bt_addr[1] = usb_bd_array[idx + 3]
            -- Now call the callback function
            usb_ep_data_in_callback(end_point,addr,bcnt)
      
            -- RJ: Could be replaced by this since only the endpoint is used.
            -- usb_ep_data_in_callback(end_point)
         end if
         
      else
         -- Last transaction was an OUT token (so getting data from the Host).         
         if defined(usb_ep_data_out_callback) then
            -- Find the start position of the end-point. End points
            -- are 4 bytes in size but we have both out endpoints and
            -- in endpoints.
            var byte idx = end_point * 8
            var byte bcnt
            bcnt = usb_bd_array[ idx + 1 ]
            
            var byte BDNSTAT = usb_bd_array[idx]
            var bit own_bit at BDNSTAT : USB_BDSTATUS_UOWN
            if (own_bit == 0) then
               -- The MCU owns the buffer descriptor.               
               var word addr
               var byte bt_addr[2] at addr               
               bt_addr[0] = usb_bd_array[ idx + 2 ]
               bt_addr[1] = usb_bd_array[ idx + 3 ]
               usb_ep_data_out_callback( end_point, addr, bcnt )
            else
               if USB_DEBUG_HIGH > 0 then
                  print_string(serial_hw_data," Do not own EP buffer! ")
               end if
            end if -- own_bit
          else
            -- RJ: TODO. The fixed 8 should be replaced by the size of the 
            --           endpoint buffer.
            usb_prime_epx_out( end_point, 0x08 )
         end if -- defined(usb_ep_data_out_callback)
         
      end if -- USTAT_DIR
   end if -- end_point
   
end procedure

-- --------------------------------------------------------------------------------------
-- Internal procedure to reset the USB device
-- Reset is initiated by the Host.
-- --------------------------------------------------------------------------------------
procedure _usb_handle_reset() is
   pragma inline

   UEIR = 0 -- No error interrupts
   UIR  = 0 -- Clear all interrupt flags
   
   if USB_DEBUG > 0 then
      print_crlf(serial_hw_data)
      serial_hw_write( "C" )
      print_byte_hex(serial_hw_data,  UCFG )
      serial_hw_write( "D" )
      print_byte_hex(serial_hw_data,  UCON )
   end if
   
   -- UADRR is 0x00 after reset and will be set after a request
   usb_address = 0 
   
   -- init buffers
   UEP1 = 0x00
   UEP2 = 0x00
   UEP3 = 0x00
   UEP4 = 0x00
   UEP5 = 0x00
   UEP6 = 0x00
   UEP7 = 0x00
   if defined( UEP8 ) == true then
      UEP8 = 0x00
   end if
   if defined( UEP9 ) == true then
      UEP9 = 0x00
   end if
   if defined( UEP10 ) == true then
      UEP10 = 0x00
   end if
   if defined( UEP11 ) == true then
      UEP11 = 0x00
   end if
   if defined( UEP12 ) == true then
      UEP12 = 0x00
   end if
   if defined( UEP13 ) == true then
      UEP13 = 0x00
   end if
   if defined( UEP14 ) == true then
      UEP14 = 0x00
   end if
   if defined( UEP15 ) == true then
      UEP15 = 0x00
   end if
   
   -- Set endpoint output and input enable and enable endpoint handshake
   UEP0 = USB_EP_CTRL | USB_HSHK_EN
   
   while UIR_TRNIF == 1 loop
      -- clear fifo (4 bytes deep)
      UIR_TRNIF = low	
   end loop
   
   -- Reset internal mode and state.
   usb_control_mode = USB_CM_IDLE
   usb_status   = USB_STATUS_IDLE
   
   -- Make sure packet processing is enabled
   UCON_PKTDIS = 0
   
   -- EP0 IN
   usb_bd0in_cnt = 8
   usb_bd0in_addr = USB_EP0_IN_ADDR
   -- clear UOWN bit, uC owns buffer
   usb_bd0in_stat = 0x00
   
   -- EP0 OUT
   usb_bd0out_cnt  = 8
   usb_bd0out_addr = USB_EP0_OUT_ADDR
   -- set UOWN bit, SIE owns the buffer since we expect first transaction to be SETUP
   var volatile bit uown_bit at usb_bd0out_stat : USB_BDSTATUS_UOWN
   -- RJ: According to the datasheet the UOWN bit must not be set at the same time
   -- the other bits in the bd status register are set.
   usb_bd0out_stat = 0x0C  -- Set without UOWN
   uown_bit = TRUE         -- Now set UOWN
 
   if USB_DEBUG > 0 then
      print_crlf(serial_hw_data)
      serial_hw_write("U")
      print_byte_hex(serial_hw_data,UEP0)
   end if
      
   if defined (usb_reset_callback) then
      usb_reset_callback()
   end if
   
end procedure

-- --------------------------------------------------------------------------------------
-- Procedure can be called when the USB device has to be stalled
-- --------------------------------------------------------------------------------------
procedure usb_handle_stall() is
   pragma inline
   if USB_DEBUG > 0 then
      print_string( serial_hw_data," U:Stall ")
   end if
end procedure


-- --------------------------------------------------------------------------------------
-- This is the heart of the USB library, all pending IO transfers are handled by
-- this main (interrupt) service routine. The routine can be used interrupt based
-- or by polling. 
-- When using interrupt, it will occur at least once ever 1 ms since the Start Of
-- Frame (SOF) package is sent every 1 ms by the Host.
-- --------------------------------------------------------------------------------------
procedure usb_handle_isr() is  

   var bit do_interrupt 

   if defined(USB_INTERRUPT_DRIVEN) then
      pragma interrupt  
      -- When using interrupt we must also check the interrupt USB enable bit.
      do_interrupt = _USB_INTERRUPT_FLAG & _USB_INTERRUPT_ENABLE
   else
      -- When polling we do not care about the USB enable bit.
      do_interrupt = _USB_INTERRUPT_FLAG
   end if

   if do_interrupt then

      _USB_INTERRUPT_FLAG = LOW
      
      -- The USB status FIFO is 4 bytes deep, read all (if available).
      for 4 loop
         if ( UIR_TRNIF ) then				
            _usb_handle_transaction()
            UIR_TRNIF = low
         end if
      end loop	
      
      if ( UIR_URSTIF ) then
         if USB_DEBUG > 0 then		
            print_string(serial_hw_data," !RESET ")
         end if
         
         _usb_handle_reset();
         UIR_URSTIF = low
      end if	
            
      if ( UIR_STALLIF ) then
         if USB_DEBUG > 0 then					
            print_string(serial_hw_data," !STALL ")
         end if	
         usb_handle_stall();
         UIR_STALLIF = low
      end if
      
      -- This interrupt is not enabled.
      if UIR_ACTVIF then
         if USB_DEBUG > 0 then		
            print_string( serial_hw_data," !ACTIVE ")
         end if
         UIR_ACTVIF = low
      end if

      -- This interrupt is not enabled.
      if ( UIR_IDLEIF ) then
         if USB_DEBUG > 0 then		
            print_string( serial_hw_data," !IDLE ")
         end if
         UIR_IDLEIF = low
      end if
      
      if ( UIR_SOFIF ) then
         -- This occurs every 1 ms if interrupt is enabled.
         -- RJ: Disable printing when debugging with interrupt enabled
         --     since it will be too fast to handle via the USART.
         if USB_DEBUG > 0 then		
            -- print_string( serial_hw_data," !SOF ") -- Disabled
         end if

         if defined( usb_sof_callback ) then
            usb_sof_callback()
         end if
         UIR_SOFIF = low
      end if
      
      if ( UIR_UERRIF ) then
         if USB_DEBUG > 0 then		
            print_string( serial_hw_data," !ERROR ")
         end if
         UIR_UERRIF = low
      end if

   end if 

end procedure


-- --------------------------------------------------------------------------------------
-- Internal procedure to set the correct interrupt flags. The driver can be used
-- interrupt driven or on a polling basis.
-- --------------------------------------------------------------------------------------
procedure _usb_ints_on() is

   -- Enable the relevant interrupts.
   UIE_SOFIE   = HIGH  -- Interrupt on start of frame token
   UIE_STALLIE = HIGH  -- Interrupt on stall
   UIE_IDLEIE  = LOW   -- No interrupt on idle detect
   UIE_TRNIE   = HIGH  -- Interrupt on transaction complete
   UIE_ACTVIE  = LOW   -- No interrupt on bus activity detect
   UIE_UERRIE  = HIGH  -- Interrupt on error
   UIE_URSTIE  = HIGH  -- Interrupt on reset 

   if defined(USB_INTERRUPT_DRIVEN) then   
      -- Enable USB, peripheral and global interrupt.
      _USB_INTERRUPT_ENABLE = TRUE
      INTCON_PEIE           = TRUE
      INTCON_GIE            = TRUE
    else
      -- No USB interrupts used.
      _USB_INTERRUPT_ENABLE = FALSE
    end if
    
end procedure


-- --------------------------------------------------------------------------------------
-- Procedure to intialize the USB device, it will only do the setup, to enable
-- the USB device, use the usb_enable() procedure
-- --------------------------------------------------------------------------------------
procedure usb_setup() is
   pragma inline
   usb_state = USB_STATE_POWERED;
   
   UCON = 0x00
   
   -- setup USB configuration (Speed, ping-ping buffers, transeiver enabled, pull up configuration
   UCFG = USB_SPEED_OPTION | USB_TRANSCEIVER_OPTION | USB_PULLUP_OPTION | USB_PING_PONG__NO_PING_PONG
   
   -- enable the interrupt flags
   _usb_ints_on()
end procedure

-- --------------------------------------------------------------------------------------
-- Get the state of the USB device
-- 
-- USB_STATE_POWERED -> USB device is powered up, ready to start negotiating
-- USB_STATE_DEFAULT -> USB device is now negotiating
-- USB_STATE_ADDRESS -> USB device now has an address
-- USB_STATE_CONFIGURED -> USB device is completely configured and ready to rock and roll 
-- --------------------------------------------------------------------------------------
function usb_get_state() return byte is
   pragma inline
   return usb_state
end function


-- --------------------------------------------------------------------------------------
-- Function returns true if the usb device has been completely configured, otherwise
-- return value will be false
-- --------------------------------------------------------------------------------------
function usb_is_configured() return bit is
   if ( usb_state == USB_STATE_CONFIGURED ) then
      return TRUE
   else
      return FALSE
   end if
end function


-- --------------------------------------------------------------------------------------
-- Procedure to turn on the USB device
-- --------------------------------------------------------------------------------------
procedure usb_enable_module() is 
   pragma inline

   UIR  = 0      -- Clear all interrupt status flags
   UCON = 0x00
   
   -- If we use the PLL we have to wait until it is ready before enabling
   -- the USB serial interface. Note that some PICs have a PLL ready 
   -- indicator, if not then we wait for the required 2 ms.
  if defined(_USB_OSC_PLLEN) then
     if defined(_USB_OSC_PLLRDY) then
         while !_USB_OSC_PLLRDY loop  
            -- Wait for PLL to be ready.
         end loop
      else
         -- For PICs without a PLL ready,  wait for 2 ms.
         _usec_delay(2_000)
      end if
   end if

   -- enable USB serial interface engine (SIE)
   UCON_USBEN = high 
   usb_state = USB_STATE_DEFAULT
   
end procedure

