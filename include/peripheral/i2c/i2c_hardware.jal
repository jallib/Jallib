-- Title: i2c_hardware
-- Author: Stef Mientki, Copyright (C) 2005..2024, all rights reserved.
-- Adapted-by: Joep Suijs, Albert Faber, Rob Jansen
-- Compiler: 2.5r8
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Hardware implementation of I2C (single) master.
-- .
-- Define i2c pins like:
-- alias i2c_scl            is pin_c3              -- optional
-- alias i2c_scl_direction  is pin_c3_direction
-- alias i2c_sda            is pin_c4              -- optional
-- alias i2c_sda_direction  is pin_c4_direction
-- - --
-- const word _i2c_bus_speed = 1                   -- 100kHz
-- const bit  _i2c_level     = true                -- i2c levels (not SMB)
--
-- The use can define a timeout as to prevent a hangup in case something goes wrong. The
-- timing is not exact but a reference of 1 us is used but since the loop time increases
-- it this time should be seen as the minimum wait time before it expires. This is an
-- optional setting: 
-- const word I2C_HARDWARE_TIMEOUT = 10_000  -- Timeout is al least 10 ms.
--

-- Aliases to support other PICs.
if (defined(PIE3_SSP1IE) == TRUE) then             -- PIE3/PIR3
   alias PIR1_SSPIF is PIR3_SSP1IF
   alias PIE1_SSPIE is PIE3_SSP1IE
end if

-- --------------------------------------------------------------------
-- some constants needed for the baudrate generator
-- --------------------------------------------------------------------
const _i2c_slowest = 127                  -- (40 kHz @ 20 MHz Fosc)
const _i2c_100khz  = target_clock /   100_000 / 4 - 1
const _i2c_400khz  = target_clock /   400_000 / 4 - 1
const _i2c_1mhz    = target_clock / 1_000_000 / 4 - 1
-- --------------------------------------------------------------------

-- --------------------------------------------------------------------
-- if the device has changed, change the speed if necessary
-- --------------------------------------------------------------------
procedure i2c_initialize() is

   -- One time initialize ---------------------------------------------
   -- i2c requires to set TRIS bits to input
   -- so to be sure ...
   pin_SCL_direction = input
   pin_SDA_direction = input

   sspcon1 = 0b0010_1000   -- set up as master device
   sspcon2 = 0b0010_0000   -- sets default acknowledge bit value
   -- -----------------------------------------------------------------

   -- set correct speed
   if    _i2c_bus_speed == 10 then sspadd = _i2c_1mhz
   elsif _i2c_bus_speed ==  4 then sspadd = _i2c_400khz
   elsif _i2c_bus_speed ==  1 then sspadd = _i2c_100khz
   elsif _i2c_bus_speed ==  0 then sspadd = _i2c_slowest
   else                            sspadd = _i2c_100khz      -- default
   end if

   -- set correct level
   -- SMP-bit7 = 0, slew rate enabled, better for EMC
   if _i2c_level then
      sspstat = 0b_0000_0000                       -- i2c bus levels, CKE=0
   else
      sspstat = 0b_0100_0000                       -- SMbus levels, CKE=1
   end if
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- i2c_start - Sends Start bit and waits until finished or timeout (if defined)
-- -----------------------------------------------------------------------------
procedure i2c_start() is

   SSPCON2_SEN = high
   if defined(I2C_HARDWARE_TIMEOUT) then
      var word timeout_counter = 0
      while (SSPCON2_SEN == high) & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
   else
      -- Without timeout.
      while SSPCON2_SEN == high loop end loop
   end if 

end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_restart - Sends Restart bit and waits until finished or timeout (if defined)
-- -----------------------------------------------------------------------------
procedure i2c_restart() is

   SSPCON2_RSEN = high
   if defined(I2C_HARDWARE_TIMEOUT) then
      var word timeout_counter = 0
      while (SSPCON2_RSEN == high) & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
   else
      -- Without timeout.
      while SSPCON2_RSEN == high loop end loop
   end if 

end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_stop - Sends Stop bit and waits until finished or timeout (if defined)
-- -----------------------------------------------------------------------------
procedure i2c_stop() is

   SSPCON2_PEN = high
   if defined(I2C_HARDWARE_TIMEOUT) then
      var word timeout_counter = 0
      while (SSPCON2_PEN == high) & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
   else
      -- Without timeout.
      while SSPCON2_PEN == high loop end loop
   end if 

end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_transmit_byte. Returns TRUE when OK and FALSE in case of an error or  
-- when a timeout occurs (if defined)
-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------
function i2c_transmit_byte(byte in data) return bit is

   var bit succes = TRUE

   PIR1_SSPIF = false  ; clear pending flag
   sspbuf = data       ; write data

   -- wait untill write is finished
   if defined(I2C_HARDWARE_TIMEOUT) then
      var word timeout_counter = 0
      while !PIR1_SSPIF & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
      if (timeout_counter == I2C_HARDWARE_TIMEOUT) then
         succes = false
      else
         -- get Acknowledge Status Bit _ACKSTAT
         -- wich indicates that the slave has responded (or not)
         -- if i2c device send an Aknowledge, then ready and OK
         if SSPCON2_ACKSTAT == low  then
            succes = true -- okay
         else
            sspcon1_sspen = false;
            sspcon1_sspen = true;
            succes = false -- no response
         end if
      end if 
   else
      -- Without timeout.
      while !PIR1_SSPIF loop end loop

      -- get Acknowledge Status Bit _ACKSTAT
      -- wich indicates that the slave has responded (or not)
      -- if i2c device send an Aknowledge, then ready and OK
      if SSPCON2_ACKSTAT == low  then
         succes = true -- okay
      else
         sspcon1_sspen = false;
         sspcon1_sspen = true;
         succes = false -- no response
      end if
   end if 

   return succes

end function
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_receive_byte -
-- -----------------------------------------------------------------------------
-- start receiving of a byte and waits till finished or timeout (if defined)
-- if param ACK is true, the byte is acknowledged and next bytes can be received.
-- if param ACK is false, the byte is nacked and a stop *should be* sent.
-- note: this behavior is inverted from the line level and orignal library, but
--       consistent with the i2c_software library.
-- -----------------------------------------------------------------------------
function i2c_receive_byte(bit in ACK ) return byte is

   var byte data
   -- start receive cyclus and wait till full byte received
   SSPCON2_RCEN = high
   
   if defined(I2C_HARDWARE_TIMEOUT) then
      var word timeout_counter = 0
      while (SSPSTAT_BF == low) & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
   else
      -- Without timeout.
      while SSPSTAT_BF == low loop  end loop
   end if

   -- send Acknowledge (=low) if STOP=true=high
   -- and wait till finishd
   SSPCON2_ACKDT = ! ACK
   SSPCON2_ACKEN = high
   if defined(I2C_HARDWARE_TIMEOUT) then
      while (SSPCON2_ACKEN == high) & (timeout_counter != I2C_HARDWARE_TIMEOUT) loop 
         timeout_counter = timeout_counter + 1
         _usec_delay(1)
      end loop
   else
      -- Without timeout.
      while SSPCON2_ACKEN == high loop end loop
   end if 

   -- get read data
   data = sspbuf
   return data
   
end function
-- -----------------------------------------------------------------------------





