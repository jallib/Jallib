-- -----------------------------------------------------------------------------
-- Title: Testfile showing how to use adc_hardware library
-- Author: Sebastien Lelong, Copyright (c) 2008-2021, all rights reserved.
-- Adapted-by: Joep Suijs, Rob Hamerling, Rob Jansen
-- Compiler: 2.5r5
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this program shows how to use adc_hardware library.
-- It regurlarly performs an Analog-to-Digital Conversion, on channel 0
-- (pin_AN0) and uses the result as value for a delay to obtain a walking
-- light with 4 leds (Pickit2 low pincount prototype board).
--
-- Notes: Normally it is safe to use the Frc clock for the ADC but when testing, the
--        ADC got stuck. From a forum this was posted:
--        "When the ADC is configured to operate with the internal FRC oscillator 
--        (ADCON2<2:0> = X11) and the device is not in Sleep, then the ADC may fail 
--        to complete the conversion which is indicated by the GO/DONE bit of the 
--        ADCON0 register remaining in the GO state indefinitely."
--        And indeed the ADC did hang when using the Frc as clock. Because of that
--        a switch was made to use Fosc/32 (2 us) which is OK for a clock of 16 MHz.
--
-- Few words about diagram: this program performs ADC on channel AN0, so you can measure
-- any voltage source connected to these channels (no more than 5V please).
-- To test the whole, you can use a voltage divider:
--
--     5V
--     |
--     Z
--     Z R1        -----------
--     Z           |
--     |------ AN0-|   PIC
--     Z           |
--     Z R2        |
--     Z
--     |
--    GND
--
--
-- - R1=1K, R2=1K: you should get ~127 as ADC value (low)
-- - R1=1K, R2=2.2K: you should get ~175 as ADC value (low)
--
-- This file has been generated by hand (manually maintained)
-- 
-- Sources:
--
-- Notes:
--
-- -----------------------------------------------------------------------------
--

include 16f1827

-- Internal osc, running at 16 MHz
pragma target clock  16_000_000

-- fuses
pragma target OSC      INTOSC_NOCLKOUT
pragma target WDT      DISABLED
pragma target PWRTE    DISABLED
pragma target MCLR     EXTERNAL
pragma target CP       DISABLED
pragma target CPD      DISABLED
pragma target BROWNOUT DISABLED
pragma target CLKOUTEN DISABLED
pragma target IESO     DISABLED
pragma target FCMEN    DISABLED
pragma target WRT      DISABLED
pragma target PLLEN    DISABLED
pragma target STVR     DISABLED
pragma target VOLTAGE  MAXIMUM
pragma target LVP      ENABLED 

OSCCON_SPLLEN = 0                           -- no PLL
OSCCON_IRCF   = 0b1111                      -- 16 MHz
OSCCON_SCS    = 0b00                        -- clock determined by fuse setting

enable_digital_io()                         -- all pins digital I/O

include delay

-- Step 1: ADC analog input pin setup we wil use channel 0
pin_AN0_direction = input 
ANSELA_ANSA0 = TRUE 
-- Step 2: Set VDD and VSS as Vref
ADCON1_ADPREF = 0b00
ADCON1_ADNREF = FALSE
-- Step 3: Use Fosc/32 as ADC clock 
ADCON1_ADCS = 0b010 
-- Now we can include the library
include adc
-- And initialize the whole with our parameters
adc_init()

alias led1 is pin_B0                   -- )
alias led2 is pin_B1                   -- )
alias led3 is pin_B2                   -- ) 4 leds lit up in sequence
alias led4 is pin_B3                   -- )
portB_low_direction = all_output       -- )

forever loop

   led1 = on
   delay_1ms(adc_read_low_res(0))      -- lit for ?? milliseconds
   led1 = off

   led2 = on
   delay_1ms(adc_read_low_res(0))
   led2 = off

   led3 = on
   delay_1ms(adc_read_low_res(0))
   led3 = off

   led4 = on
   delay_1ms(adc_read_low_res(0))
   led4 = off

end loop

