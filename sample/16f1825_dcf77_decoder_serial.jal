-- -----------------------------------------------------------------------------
-- Title: Sample program for the DCF77 Decoder
-- Author: Rob Jansen, Copyright (c) 2023..2023, all rights reserved.
-- Adapted-by:
-- Compiler: 2.5r8
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Sample program that shows the operation of the DCF77 decoder 
--              library. The sample program shows a software clock with time,
--              date and day of the week which is synchronized with the 
--              information given by the DCF77 transmiter. 
--              The serial interface is used to display the information.
--              The DCF77 library uses timer 1 to measure the bit-times. This
--              timer must be set to overflow every 1 ms.
-- 
-- Note:        The PIC runs at a low internal clock of 4 MHz since the DCF77
--              signal has a low bitrate. This will also reduce the amonunt of
--              noise generated by the PIC and so increase sensitivity.
-- 
include 16f1825                 

-- This program uses the internal oscillator at 4 MHz.
pragma target clock    4_000_000       -- oscillator frequency
pragma target OSC      INTOSC_NOCLKOUT -- Internal Clock
pragma target PLLEN    DISABLED        -- No PLL
pragma target WDT      DISABLED        -- No Watchdog
pragma target PWRTE    ENABLED         -- Power up timer enabled
pragma target BROWNOUT DISABLED        -- No brownout reset
pragma target FCMEN    DISABLED        -- No clock monitoring
pragma target IESO     DISABLED        -- int/ext osc. switch
pragma target LVP      ENABLED         -- Low voltage programming
pragma target MCLR     EXTERNAL        -- Reset external
-- Set the internal clock frequency to 4 MHz.
OSCCON_IRCF   = 0b1101                 -- Set 4 MHz
OSCCON_SCS    = 0b00                   -- Clock determined by FOSC

-- Enable weak pull up. Weak pull-up on the interrupt pin is not needed.
WPUA = 0b0011_1111       -- Weak pull-up on all pins.
WPUC = 0b0011_1111       -- Weak pull-up on all pins.
OPTION_REG_WPUEN = FALSE -- Enable Weak Pull-Up

enable_digital_io()      -- All pins digital IO
_usec_delay(250_000)     -- Give the hardware some time to stabilize.

-- Before including the GPS library, select a serial interface. You can select
-- from serial_hardware or serial_hardware2, this because the library captures 
-- and processes the data on an interrupt basis. Only USART reception is used
-- by the library. The main program can still use the USART for transmission.
alias pin_RX_direction is pin_RX_RC5_direction -- Pin 5 of 14 pin DIP to TX of GPS Module
alias pin_TX_direction is pin_TX_RC4_direction -- Pin 6 of 14 pin DIP to Computer
const serial_hw_baudrate = 9600
include serial_hardware                        
serial_hw_init
alias serial is serial_hw_data

include print
-- Settings for the DCF77 Decoder. The decoder uses timer 1 to get an overflow
-- interrupt every 1 ms. In this case we use Fosc/4 and a prescaler of 1:8 to 
-- get a 1 MHz timer 1 clock since the target clock is at 4 MHz.
T1CON_TMR1CS = 0b00 -- Clock source Fosc/4, gives 1 MHz.
T1CON_T1CKPS = 0b00 -- Prescaler 1:1, gives 1 MHz.
-- Set the timer 1 reload value to get an overflow after 1 ms time. Timer is
-- running at 1 MHz. 
const word DCF77_TIMER_1_RELOAD = 65535 - 1_000

-- The following local constant is normally not required but is used here to 
-- demonstrate the use of the IOC version. If you comment this constant
-- out the DCF77 decoder will use the external interrupt (default).
-- const IOC_VERSION = TRUE
if defined(IOC_VERSION) then
   -- Set the IOC interrupt on both edges and define the and aliases 
   -- for the decoder routine. We use pin A5 in this example.
   IOCAP_IOCAP5 = TRUE -- Set ioc interrupt on positive edge
   IOCAN_IOCAN5 = TRUE -- Set ioc interrupt on negative edge.
   alias dcf77_decoder_ioc_flag is IOCAF_IOCAF5
   -- Interupt pin using IOC.
   alias dcf77_decoder_pin_direction is pin_a5_direction -- Pin 2 for 14 pin DIP
else
   -- Interupt pin using the external interrupt.
   alias dcf77_decoder_pin_direction is pin_a2_direction -- Pin 11 for 14 pin DIP
end if 

-- Now we can include the library.
include dcf77_decoder
dcf77_decoder_init()

-- Variables.
var word second_counter 
var byte hours, minutes, seconds
var byte day, month, year
var bit  second_passed

-- Timer 2 interrupt procedure. Sets a 1 second flag.
procedure timer_2_interrupt() is
   pragma interrupt

   if PIR1_TMR2IF then
      PIR1_TMR2IF = FALSE
      second_counter = second_counter + 1
      if (second_counter == 1_000) then
         second_counter = 0
         second_passed = TRUE
      end if 
   end if

end procedure

-- Print a decimal value always with leading zero's.
procedure print_decimal(byte in value) is
   if (value < 10) then
      serial = "0"
   end if
   print_byte_dec(serial, value)
end procedure

-- Print the given day of the week.
procedure print_day(byte in day) is

   case day of
      1: print_string(serial, "Monday")
      2: print_string(serial, "Tuesday")
      3: print_string(serial, "Wednesday")
      4: print_string(serial, "Thursday")
      5: print_string(serial, "Friday")
      6: print_string(serial, "Saturday")
      7: print_string(serial, "Sunday")
   end case

end procedure

-- Main program starts here.
hours = 0
minutes = 0
seconds = 0

-- Make a timer that can give a signal of 1 second for the sofware clock. 
-- Use Timer 2. Register PR2 holds the PWM Timer Period using the following 
-- formula: Period = (PR2 + 1) * 4 * Tosc * prescale value * postscale value 
-- where Tosc = 1/Fosc and Fosc = 4 MHz.Setting the prescaler to 4 and PR2 
-- at 249: (249 + 1) * 4 * 1/4.000.000 * 4 * 1 = 1 ms. Period Cycle = 1 kHz.
T2CON_TMR2ON = FALSE
T2CON_T2OUTPS = 0b0000 -- Postscaler is 1:1 (no postscaling).
T2CON_T2CKPS = 0b01    -- Prescaler divide by 4
PR2 = 249 
PIE1_TMR2IE = TRUE
INTCON_PEIE = TRUE
T2CON_TMR2ON = TRUE

print_string(serial, "Sample program for the DCF77 decoder\r\n")

forever  loop 

   -- Run the software clock.
   if second_passed then
      second_passed = FALSE
      seconds = seconds + 1
      if (seconds == 60) then
         seconds = 0
         minutes = minutes + 1
         if (minutes == 60) then
            minutes = 0
            hours = hours + 1
            if (hours == 24) then
               hours = 0
            end if 
         end if 
      end if 
      -- Write the clock.
      print_string(serial, "Time: ")
      print_decimal(hours)
      serial = ":"
      print_decimal(minutes)
      serial = ":"
      print_decimal(seconds)
      print_crlf(serial)
   end if 

   -- See if we can synchronize our clock with the DCF77 time.
   if dcf77_message_received() then
      -- We only get hours and minutes, assume seconds is zero.
      seconds = 0
      hours = dcf77_get_hours()
      minutes = dcf77_get_minutes()

      -- Print the other DCF77 information.
      -- CET or CEST.
      if dcf77_time_is_cet() then
         print_string(serial, "Time is Central European Time.\r\n")
      elsif dcf77_time_is_cest() then
         print_string(serial, "Time is Central European Summer Time.\r\n")
      end if 

      -- Day of the week.
      print_string(serial, "Day: ")
      print_day(dcf77_get_day_of_week())
      print_crlf(serial)

      -- Date.
      print_string(serial, "Date: ")
      print_decimal(dcf77_get_day_of_month())
      serial = "-"
      print_decimal(dcf77_get_month())
      print_string(serial, "-20")
      print_decimal(dcf77_get_year_within_century())
      print_crlf(serial)
     
   end if

end loop
