-- Title: USB HID generic device demo
-- Author: Albert Faber, Copyright (c) 2008..2014, all rights reserved.
-- Adapted-by: Joep Suijs
-- Compiler: >=2.4q2
-- 
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: This sample implements a generic HID device. The advantage of a generic
-- HID device is that it can use the HID driver on the HOST operation system.
-- 
-- Sources: http://www.usb.org for USB specifications
-- 
-- Notes: compiled with following flags
-- -loader18 -no-fuse -no-variable-reuse
-- -no-variable-reuse must be used 
--  due to a compiler issue
-- 
-- ------------------------------------------------------
-- ------------------------------------------------------
-- 
-- compiled with following flags: -loader18 -no-fuse -no-variable-reuse
--
-- This file has been generated by jallib.py from:
--    * board: board_18f67j50_ms.jal
--    * test : test_usb_hid_generic.jal
--

;@jallib section chipdef
-- chip setup
include 18f67j50                   -- target PICmicro
--
-- Compiler directives
pragma target CLOCK    48_000_000  -- CPU frequency
--
-- Configuration memory settings (fuses)
pragma target OSC      INTOSC_NOCLKOUT_PLL      -- internal oscillator
                                                -- and using PLL
pragma target PLLDIV   P2          -- reduce OSC 20->4 MHz for PLL input
pragma target CPUDIV   P1          -- CPU freq. from PLL(96/2): 48 MHz
pragma target FCMEN    DISABLED    -- no fail-safeclock monitoring
pragma target IESO     DISABLED    -- no in/ext oscillator switchover
pragma target WDT      CONTROL     -- watchdog software controlled
pragma target XINST    DISABLED    -- not supported by JalV2
pragma target DEBUG    DISABLED    -- no debugging

WDTCON_SWDTEN = OFF                 -- disable watchdog

-- Note: Not specified:
--       Code protection, Boot Block Code protection, Data EEPROM protection,
--       Write protection, Configuration Memory write protection,
--       Table Read protection, Boot Block Table Read protection,
--       and maybe some other configuration bits.
--
OSCCON_SCS = 0b00                  -- select primary clock source
OSCTUNE_PLLEN = enabled            -- activate PLL module
--
WDTCON_SWDTEN = OFF                -- disable WDT
--
_usec_delay (1_000)                -- allow PLL to stabilize

include delay

;@jallib section serial

-- whether or not using the serial port
const HAS_SERIAL_DEBUG_PORT = 1

if defined( HAS_SERIAL_DEBUG_PORT ) == true then

	const serial_hw_baudrate = 115_200
	
	include serial_hardware
	include format
	include print
	
	-- intialze serial device
	serial_hw_init()

	procedure serial_print_spc() is 
		serial_hw_write( " " )
	end procedure

	procedure serial_newline() is
		serial_hw_write( 10 )
		-- serial_hw_write( 13 )
	end procedure
end if



const bit USB_DEBUG = false
const bit USB_DEBUG_HIGH = false

const bit USB_HID_DEBUG = false
const bit USB_HID_DEBUG_HIGH = false
const byte USB_HID_ENDPOINT = 0x01

include usb_defs

const bit USB_EP0 = 1
const byte USB_EP0_OUT_SIZE = 8
const word USB_EP0_OUT_ADDR = ( USB_BASE_ADDRESS + 0x0010 )
const byte USB_EP0_IN_SIZE  = 8
const word USB_EP0_IN_ADDR  = ( USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )

const bit USB_EP1 = 1
const byte USB_EP1_OUT_SIZE = 8
const word USB_EP1_OUT_ADDR = ( USB_EP0_IN_ADDR + USB_EP0_IN_SIZE )
const byte USB_EP1_IN_SIZE  = 8
const word USB_EP1_IN_ADDR  = ( USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE )

var volatile byte  usb_ep1in_buf[ 8 ] at USB_EP1_IN_ADDR

const bit USB_EP2 = 0
const byte USB_EP2_OUT_SIZE = 8
const word USB_EP2_OUT_ADDR = 0x0000
const byte USB_EP2_IN_SIZE  = 8
const word USB_EP2_IN_ADDR  = 0x0000

const bit USB_EP3 = 0
const byte USB_EP3_OUT_SIZE = 8
const word USB_EP3_OUT_ADDR = 0x0000
const byte USB_EP3_IN_SIZE = 8
const word USB_EP3_IN_ADDR  = 0x0000


const byte HID_OUT_REPORT_SIZE = 8

const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] = {
	USB_DEVICE_DESCRIPTOR_SIZE, 	-- 18 bytes long
	USB_DT_DEVICE, 	-- DEVICE 01h
	0x00,
	0x02,		-- usb version 2.00
	0x00,		-- class
	0x00,		-- subclass
	0x00,		-- protocol
	0x08,		-- max packet size for end point 0
	0x25,
	0x09,		-- Vendor ID
	0x01,
	0x70,		-- Product ID
	0x01,
	0x00, 	    -- version 0.1 of the product
	0x01,		-- string 1 for manufacturer
	0x02,		-- string 2 for product
	0x00,		-- string 3 for serial number
	0x01		-- number of configurations
}	


const byte USB_HID_REPORT1[]=
{

	0x06, 0xA0, 0xFF,			-- Usage page (vendor defined) 
	0x09, 0x01,					-- Usage ID (vendor defined)
	0xA1, 0x01,					-- Collection (application)

	-- The Input report
	0x09, 0x03,     			-- Usage ID - vendor defined
	0x15, 0x00,     			-- Logical Minimum (0)
	0x26, 0xFF, 0x00,   		-- Logical Maximum (255)
	0x75, 0x08,     			-- Report Size (8 bits)
	0x95, HID_OUT_REPORT_SIZE, 	-- Report Count	(8 fields)				
	0x81, 0x02,     			-- Input (Data, Variable, Absolute)  

	-- The Output report
	0x09, 0x04,     			-- Usage ID - vendor defined
	0x15, 0x00,     			-- Logical Minimum (0)
	0x26, 0xFF, 0x00,   		-- Logical Maximum (255)
	0x75, 0x08,     			-- Report Size (8 bits)
	0x95, HID_OUT_REPORT_SIZE,  -- Report Count (8 fields)
	0x91, 0x02,      			-- Output (Data, Variable, Absolute)  

	-- The Feature report
	0x09, 0x05,     			-- Usage ID - vendor defined
	0x15, 0x00,     			-- Logical Minimum (0)
	0x26, 0xFF, 0x00,   		-- Logical Maximum (255)
	0x75, 0x08,					-- Report Size (8 bits)
	0x95, HID_OUT_REPORT_SIZE, 	-- Report Count	(8 fields)				
	0xB1, 0x02,     			-- Feature (Data, Variable, Absolute)  

	0xC0						-- end collection
}

const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x09 + 0x07 + 0x07

const byte USB_CONFIGURATION_DESCRIPTOR[ USB_CONFIGURATION_DESCRIPTOR_SIZE ]=
{	
	-- configuration descriptor - - - - - - - - - - 
	0x09,	-- length,
	USB_DT_CONFIGURATION,	-- descriptor_type

	USB_CONFIGURATION_DESCRIPTOR_SIZE,
	0x00,	-- total_length;
	
	0x01,	-- num_interfaces,
	0x01,	-- configuration_value,
	0x00,	-- configuration_string_id,
	0b10000000, -- attributes (bus powered, no remote wake up)
	100,	-- max_power; (200ma)

	-- interface descriptor - - - - - - - - - - - -
	0x09,	-- length,
	USB_DT_INTERFACE,	-- descriptor_type,
	0x00,	-- interface_number, (starts at zero)
	0x00,	-- alternate_setting, (no alternatives)
	0x02,	-- num_endpoints,
	USB_HID_INTF,	-- interface_class, (HID)
	0x00,	-- interface_subclass
	0x00,	-- interface_protocol
	0x00,	-- interface_string_id;
	
	-- hid descriptor - - - - - - - - - - - - - - -
	0x09,				-- length,
	USB_DT_HID,			-- descriptor_type;
	0x11,
	0x01,				-- hid_spec in BCD (1.11)
	0x00,				-- country_code, (0=not country specific)
	0x01,				-- num_class_descriptors, (1)
	USB_DT_HID_REPORT,	-- class_descriptor_type; (0x22 = report)
	(count( USB_HID_REPORT1 ) & 0xFF ),
	(count( USB_HID_REPORT1 ) >> 8 ),
	
	0x07,				-- length,
	USB_DT_ENDPOINT,	-- descriptor_type,
	0b10000001,			-- endpoint_address, (Endpoint 1, IN)
	USB_EPT_INT,			-- attributes; (Interrupt)
	USB_EP1_IN_SIZE,				
	0x00,				-- max_packet_size
	0x01,				-- interval (1ms)

	0x07,				-- length,
	USB_DT_ENDPOINT,	-- descriptor_type,
	0b00000001,			-- endpoint_address, (Endpoint 1, OUT)
	USB_EPT_INT,		-- attributes; (Interrupt)
	USB_EP1_OUT_SIZE,				
	0x00,				-- max_packet_size
	0x01				-- interval (1ms)
}

const byte USB_STRING0[] = 
{
	0x04,	-- bLength
	USB_DT_STRING,	-- bDescriptorType
	0x09,	-- wLANGID[0] (low byte)
	0x04	-- wLANGID[0] (high byte)
}

const byte USB_STRING1[18] = 
{
	18,				-- bLength
	USB_DT_STRING,	-- bDescriptorType
	"J", 0x00, 
	"A", 0x00, 
	"L", 0x00, 
	" ", 0x00, 
	"L", 0x00, 
	"I", 0x00, 
	"B", 0x00, 
	".", 0x00
}

const byte USB_STRING2[48] = 
{
	48,				-- bLength
	USB_DT_STRING,	-- bDescriptorType
	"J", 0x00, 
	"A", 0x00, 
	"L", 0x00, 
	"L", 0x00, 
	"I", 0x00, 
	"B", 0x00, 
	" ", 0x00, 
	"G", 0x00, 
	"e", 0x00, 
	"n", 0x00, 
	"e", 0x00, 
	"r", 0x00, 
	"i", 0x00,
	"c", 0x00,
	" ", 0x00, 
	"H", 0x00, 
	"I", 0x00, 
	"D", 0x00, 
	" ", 0x00, 
	"D", 0x00, 
	"e", 0x00, 
	"m", 0x00, 
	"o", 0x00
}


include usb_drv_core


-- adc lib is horribly broken, it won't work K50 series, so disable for the time being
if ( 	(target_chip == PIC_18F14K50 ) |
		(target_chip == PIC_18F13K50 ) |
		(target_chip == PIC_18LF14K50 ) |
		(target_chip == PIC_18LF13K50 ) )then
	const bit no_analog = true
else
	const bit no_analog = true
end if
	
if !no_analog	then
	-------------------------------- ADC STUFF -------------------------------------
	const no_adc = 0x06
	const ADC_HARDWARE_NCHAN     = 1
	const ADC_HARDWARE_NVREF     = 0         ;number of external references
	const ADC_HARDWARE_RSOURCE   = 10_000    ;maximum source resistance
	const ADC_HARDWARE_HIGH_RESOLUTION = true ;true = high resolution = 10 bits
	
	-- get the library, after defining the constants
	include adc_hardware
	
	-- initialize the AD converter according to the above parameters
	-- LEFT JUSTIFIED, 16 TAD, FOSC / 64 
	ADCON2 = 0b_10_000_110
	adc_init()
	adc_on()
end if

-- -----------------------------------------------------------------------------

-- timer 0 offset value
const byte TMR0_OFFSET = 106

------------------------------------------------------------
-- TIMER 0 configuration
------------------------------------------------------------
-- Objection is to get a 0.1 millisecond delay
-- fclk = 48 Mhz => timer clk = fclk / 4 = 12 Mhz
-- required clock rate: 0.1 ms => 1 Khz
-- timer 0 should divide by => 12 Mhz / 1 KHz = 12000
-- set pre-scaler to 1:8 and count to 150
--
-- TMR0_OFFSET = ( 256 - 150 ) = 106
-- TMR0_delay=(256-TMR0_OFFSET)*4*prescaler/Fosc
-- TMR0_delay=(256-6)*4*4/20_000_000= 0.1 msec.
--
-- Init TMR0, free run mode,
------------------------------------------------------------

-- set timer 0, 8 bit mode, timer enabled
T0CON = 0b_11000_010

var word num_timer_ints = 0


var volatile bit usb_hid_can_tx = true

const byte USB_HID_REQ_HID 			= 0x21
const byte USB_HID_REQ_REPORT 		= 0x22
const byte USB_HID_REQ_PHYSDISCR	= 0x23

const byte USB_HCR_GET_REPORT		= 0x01
const byte USB_HCR_GET_IDLE			= 0x02
const byte USB_HCR_GET_PROTOCOL		= 0x03
const byte USB_HCR_SET_REPORT		= 0x09
const byte USB_HCR_SET_IDLE			= 0x0A
const byte USB_HCR_SET_PROTOCOL		= 0x0B



var byte hid_tx_buffer[ HID_OUT_REPORT_SIZE ]
var bit send_tx = false

var bit adc_enabled = false


-- TMR0 interrupt service routine
procedure timer_0_isr() is
    pragma interrupt

    if ( INTCON_TMR0IF )  then
        num_timer_ints = num_timer_ints + 1

        if ( num_timer_ints == 100 ) then
			-- send portA event
			hid_tx_buffer[ 0 ] = 0x10
			hid_tx_buffer[ 1 ] = PORTA
			
			send_tx = true        
		end if
        
        if ( num_timer_ints == 200 ) then
			-- send portB event
			hid_tx_buffer[ 0 ] = 0x11
			hid_tx_buffer[ 1 ] = PORTB
			
			send_tx = true        
		end if

        if ( num_timer_ints == 300 ) then
			-- send portC event
			hid_tx_buffer[ 0 ] = 0x12
			hid_tx_buffer[ 1 ] = PORTC
			
			send_tx = true        
		end if

        if ( num_timer_ints == 400 ) then
			-- send ADC event
			hid_tx_buffer[ 0 ] = 0x13
			
			send_tx = true        
		end if
		
        -- only send value every 100 ms second
        if ( num_timer_ints == 1000 ) then
        
        
			num_timer_ints = 0
			
			if adc_enabled then
				var byte adc_hbyte = 0x80
				var byte adc_lbyte = 0x00
				
				
if !no_analog then
				adc_read_bytes( 0 , adc_hbyte, adc_lbyte)
end if				
				-- send ADC event
				hid_tx_buffer[ 0 ] = 0x02
				hid_tx_buffer[ 1 ] = adc_hbyte
				hid_tx_buffer[ 2 ] = adc_lbyte
				
				send_tx = true        
			
			end if
        end if
        -- Do timer offset TMR0_OFFSET
        TMR0 = TMR0 + TMR0_OFFSET

        -- Clear timer 0 interrupt flag
        INTCON_TMR0IF = low
    end if
    
end procedure


procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
    pragma inline
    if USB_HID_DEBUG_HIGH then
        const byte str[] = " EP data in: "
        const byte str1[] = " bytes "
        print_string(serial_hw_data,str)
        print_byte_hex(serial_hw_data,byte_count & 0xFF)
        print_string(serial_hw_data,str1)
    end if
    
    -- data has been sent, so do we need to send more?
    if (end_point == USB_HID_ENDPOINT) then
        -- it's the data end point
        usb_hid_can_tx = true
               
    end if
end procedure

procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
    pragma inline

    var byte cdc_rx_next

    if USB_HID_DEBUG then
        const byte str[] = " EP data out: "
        const byte str1[] = " bytes "
        print_string(serial_hw_data,str)
        print_byte_hex(serial_hw_data,byte_count)
		serial_hw_write( " " )
        print_byte_hex(serial_hw_data, end_point )
        print_string(serial_hw_data,str1)
    end if
    
    -- We have some data!
    if (end_point == USB_HID_ENDPOINT) then
		var byte src_ptr[2] AT buffer_addr

		FSR1L = src_ptr[0]
		FSR1H = src_ptr[1]

		if USB_HID_DEBUG then
			serial_newline()
		end if
		
		var byte index
		var byte cmd
		for byte_count using index loop
			var byte value
			value = POSTINC1
			if index  == 0 then
				cmd = value
				hid_tx_buffer[ 0 ] = value
			end if
			if index  == 1 then
				hid_tx_buffer[ 1 ] = value
			end if
			
			if USB_HID_DEBUG then
				print_byte_hex(serial_hw_data,value)
				serial_hw_write( " " )
			end if
		end loop
		
	
		send_tx = true
		
		case cmd of
			0x01:
			block
				-- enable interrupts (timer 0 )
				INTCON_TMR0IE = high
				INTCON_GIE = high
			end block
			
			0x02:
			block
				-- enable interrupts (timer 0 )
				INTCON_TMR0IE = low
				INTCON_GIE = low
			end block

			0x03:
			block
				PORTC = hid_tx_buffer[ 1 ]
				if defined( HAS_SERIAL_DEBUG_PORT ) == true then    
				end if
			end block

			0x04:
			block
				adc_enabled = true
			end block

			0x05:
			block
				adc_enabled = false
			end block
			

			otherwise
			block
			
			end block
		end case
	end if
	
	usb_prime_epx_out( end_point, USB_EP1_OUT_SIZE )
	
end procedure


include usb_drv




-- set port A and B to inputs
PORTA_direction  = 0b_1111_1111
PORTC_direction  = all_output





-- constants
const  byte str_welcome[] = "JAL USB Generic HID demo version 0.10\nplease wait (takes ~10 seconds) before the device is fully configured"

-- variables
var word i = 0
var bit usb_initialized = false

var byte hid_report_in[8]

var word ticks100us = 0
var bit enable_keyboard = false


procedure usb_tasks() is    
    -- Servicing Hardware
    -- use polling method
    usb_handle_isr()
    if ( send_tx ) then
		usb_send_data(USB_HID_ENDPOINT, hid_tx_buffer, count( hid_tx_buffer ), low )
		send_tx = false
    end if

end procedure

procedure usb_hid_tx_report( byte in hid_report_in[], byte in cnt ) is
	
	while ( usb_hid_can_tx == false ) loop
		usb_tasks()
	end loop
	usb_hid_can_tx = false
	usb_send_data(USB_HID_ENDPOINT, hid_report_in, cnt , low )
end procedure

-- interrupts? No thanks
while INTCON_GIE loop
    INTCON_GIE = false
end loop

if defined( HAS_SERIAL_DEBUG_PORT ) == high then
	-- put info on RS-232 serial line
	serial_newline()
	serial_newline()

	print_string(serial_hw_data, str_welcome )
	serial_newline()
end if

-- setup the USB device
usb_setup()

-- enable USB device
usb_enable_module()

-- enable digital inputs on port B
-- enable_digital_io()

ADCON1 = 0x0E

-- main loop
forever loop
	-- poll the usb ISR function on a regular base, in order to 
	-- serve the USB requests
	usb_tasks()
	
    -- check if USB device has been configured by the HOST
    if usb_is_configured()  then

		-- note user via serial line that USB has been configured
		if usb_initialized == false then
			usb_initialized = true
			
			if defined( HAS_SERIAL_DEBUG_PORT ) == true then			
				const  byte str[] = "USB device has been configured by the HOST!"
				print_string(serial_hw_data, str )
				serial_newline()

				-- now keyboard chars can be send to the host
				enable_keyboard = true
			end if
		end if
    end if

    
	if defined( HAS_SERIAL_DEBUG_PORT ) == true then    
		if PIR1_RCIF then
		end if
	end if	
    
end loop