-- -----------------------------------------------------------------------------
-- Title: Sample showing how to use dynamic ADC library
-- Author: Sebastien Lelong, Copyright (c) 2008..2021, all rights reserved.
-- Adapted-by: Rob Jansen
-- Compiler: 2.5r5
-- Revision: $Revision$
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this program shows how to use adc library, but the dynamic way.
-- What's dynamic ? When triggering dynamic ADC, you can change the number of
-- ADC channels at runtime. Using dynamic ADC, you can adjust ADC channels at runtime, while
-- your program is running. You can also change several other parameters like
-- the resolution, Rsource, etc...
-- Note: The static version of the ADC library was removed so ADC_DYNAMIC was deprecated.
-- --
-- This sample basically shows how to select 1 or 2 channels, high or low resolution.
-- It uses two switches:
--   - sw1: connected to pin_D6, select 1 or 2 channels (toggle or no toggle)
--   - sw2: connected to pin_D7, select high or low resolution (toggle or no toggle)
-- (this setup is what you have when using Jaluino and Crumboard shield. You can have
-- a look at the following schematic:
-- http://justanotherlanguage.org/sites/default/files/crumboard_schematic.png)
-- --
-- You'll have to add two voltage dividers connected to pin_RA0 and pin_RA1.
-- Choose different resistor values in order to observe different ADC values...
-- Reproduce the following for pin_RA1 too:
--
--     5V
--     |
--     Z
--     Z R1        -----------
--     Z           |
--     |------ RAx-|   PIC
--     Z           |
--     Z R2        |
--     Z
--     |
--    GND
--
--
-- - R1=1K, R2=1K: you should get ~127/~512 as ADC value (low/high)
-- - R1=1K, R2=2.2K: you should get ~175/~704 as ADC value (low/high)
--
-- Actual output with the above given resistor values (10% tolerance on resistors).
-- Note: that since the switches toggle the functionality, the output can be different
--       (e.g. high instead of low resolution) due to the moment when a switch is 
--       (de-)activated.
-- sw1 = high, sw2 = high:
-- *) Channel 0 result in low resolution: 125
-- *) Channel 0 result in high resolution: 501
-- *)Channel 1 result in high resolution: 732
-- sw1 = low, sw2 = high:
-- *) Channel 0 result in low resolution: 125
-- *) Channel 1 result in low resolution: 183
-- *) Channel 0 result in high resolution: 503
-- *) Channel 1 result in high resolution: 732
-- sw1 = high, sw2 = low:
-- *) Channel 0 result in high resolution: 500
-- *) Channel 1 result in high resolution: 729
-- *) Channel 0 result in high resolution: 500
-- *) Channel 0 result in high resolution: 502
-- *) Channel 1 result in high resolution: 731
-- sw1 = low, sw2 = low:
-- *) Channel 0 result in low resolution: 125
-- *) Channel 1 result in low resolution: 182
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
--
-- Notes:
--
-- -----------------------------------------------------------------------------
--

include 18f4550
pragma target clock 48_000_000
-- magical statements: using a 20MHz Xtal, you can run @48MHz !
pragma target PLLDIV       P5
pragma target CPUDIV       P1
pragma target USBDIV       P2
pragma target OSC          HS_PLL

pragma target WDT  control          -- watchdog
pragma target LVP  enabled          -- allow Low Voltage Programming
pragma target MCLR external         -- reset externally

WDTCON_SWDTEN = off                 -- no watchdog

-- We'll start to set all pins as digital
-- then, using ADC lib, we'll configure needed
-- ones as analog.
enable_digital_io()

include print
include delay

-- ok, now setup serial, we'll use this
-- to get ADC measures
const serial_hw_baudrate = 115_200
include serial_hardware
serial_hw_init()

-- define inputs
alias sw1 is pin_D6
pin_D6_direction = INPUT
alias sw2 is pin_D7
pin_D7_direction = INPUT

-- led will inform user input as been processed
alias led is pin_C2
pin_C2_direction = OUTPUT

-- vars to stores states
var bit use_2_channels = FALSE
var bit use_high_resolution = FALSE
-- also store previous value to optimize input processing
-- init with different value so it's processed the first time
var bit prev_use_high_resolution = TRUE
var bit prev_use_2_channels = TRUE

-- we'll start with one channel
var byte adc_nchannel = 1
var bit adc_high_resolution = low

-- Configure ADC
-- Step 1: ADC input pin setup 
pin_AN0_direction = input                      
pin_AN1_direction = input 
-- Set A0 and A1 to analog input 
ADCON1_PCFG = 0b000
-- Step 2: Set VDD and VSS as Vref
ADCON1_VCFG0 = FALSE                            -- Vref+ is VDD
ADCON1_VCFG1 = FALSE                            -- Vref- is VSS
-- Step 3: Use Frc as ADC clock 
ADCON2_ADCS = 0b011 
-- Now we can include the library
include adc
-- And initialize the whole with our parameters
adc_init()

-- will periodically send those chars
var word wmeasure
var byte bmeasure
const byte chanstr[] = "Channel "
const byte prefix[] = " result in "
const byte highstr[] = "high "
const byte lowstr[] = "low "
const byte suffix[] = "resolution: "

procedure strobe() is
   led = HIGH
   delay_1ms(5)
   led = LOW
   delay_1ms(5)
end procedure

forever loop
   -- first we process inputs (switches)
   -- SW1: switch between 1 or 2 channels
   if sw1 == high then
      use_2_channels = ! use_2_channels
   end if
   -- SW2: switch between high or low resolution
   if sw2 == high then
      use_high_resolution = ! use_high_resolution
   end if

   -- now dynamically adjust parameters, if needed
   if use_2_channels != prev_use_2_channels then
      prev_use_2_channels = use_2_channels
      if use_2_channels == TRUE then
         adc_nchannel = 2
      else
         adc_nchannel = 1
      end if
      strobe()
   end if

   if use_high_resolution != prev_use_high_resolution then
      prev_use_high_resolution = use_high_resolution
      adc_high_resolution = use_high_resolution
      strobe()
   end if

   -- debounce push buttons
   delay_1ms(400)

   var byte channel
   for adc_nchannel using channel loop
      -- report
      print_string(serial_hw_data,chanstr)
      print_byte_dec(serial_hw_data,channel)
      print_string(serial_hw_data,prefix)

      if use_high_resolution == true then
         -- get value in high resolution
         wmeasure = adc_read_high_res(channel)
         print_string(serial_hw_data,highstr)
          print_string(serial_hw_data,suffix)
         print_word_dec(serial_hw_data,wmeasure)
      else
         -- get value
         bmeasure = adc_read_low_res(channel)
         print_string(serial_hw_data,lowstr)
         print_string(serial_hw_data,suffix)
         print_byte_dec(serial_hw_data,bmeasure)
      end if

      print_crlf(serial_hw_data)
   end loop

end loop

